#
#
# Testing Machine
#
# Copyright (C) 2012, 2013 TIS Innovation Park
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or any later version.
#
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Boston,
# MA 02110-1301, USA.
#

declare -a SCRIPTS_TO_EXECUTE
export SCRIPTS_TO_EXECUTE

ANDROID_SPEC_FILE=$(dirname $0)/../share/testingmachine/scripts/vmm-client-android-specific
if [ -f $ANDROID_SPEC_FILE ]
then
    source $ANDROID_SPEC_FILE
else
    echo "Can't find $ANDROID_SPEC_FILE"
    exit 1
fi

list_vbox_machines()
{
    debug "Listing vbox machines"
    VB_NAMES=$(vboxmanage list vms | awk 'BEGIN { FS="\""} { printf "%s;", $2}' | sed 's,\",,g' )
    SAVED_IFS=$IFS
    export IFS=";"

    if [ "$VB_NAMES" != "" ]
    then
        for VB_NAME in $VB_NAMES
        do
            if [ "$VB_NAME" != "" ]
            then
		IFS=$SAVED_IFS
		echo " |--$VB_NAME "
		CONF_CLIENT=$(find $ETC_DIRS -name *.conf 2>/dev/null | grep "clients/" | xargs grep -l $VB_NAME)
		if [ "$CONF_CLIENT" != "" ]
		then
                    VB_SHORT_NAME=$(basename $CONF_CLIENT)
                    echo " |--$VB_SHORT_NAME (client)"
		else
                    echo " |--no conf file yet"
		fi
            fi
        done
    else
         echo " no virtualbox machines found"
    fi
    IFS=$SAVED_IFS
}

list_android_machines_print_info()
{
    AD_NAME_LONG=$1
    AD_TYPE=$2

    AD_NAME=$(basename $AD_NAME_LONG)
    FOUND=false
    if [ "$AD_NAME" != "" ]
    then
	echo  "  |--$AD_NAME  ($AD_TYPE machine)"
	SUB_CLIENTS=$(find $ETC_DIRS -name *.conf 2>/dev/null | grep "clients/" | xargs grep -l $AD_NAME)
	
#	    echo "SUB_CLIENTS: $SUB_CLIENTS"
	if [ "$SUB_CLIENTS" != "" ]
	then
	    for vb in $SUB_CLIENTS
	    do
#		echo " ---- $AD_NAME"
		AD_SHORT_NAME=$(basename $vb)
		echo "     |--$AD_SHORT_NAME  (client)"  
		FOUND=true
	    done
#	    if [ "$FOUND" = "false" ]
#	    then
#		echo "      not in use"
#	    fi
	fi
    else
	echo "   no android machines found"
    fi
}


list_android_machines()
{
    debug "Listing android virtual devices"
#    AD_NAMES=$(find  ${ANDROID_AVD_DIR}/* -prune -name "*.ini" | sed 's,\.ini,,g')
    AD_NAMES_AVD=$($ANDROID list avd | grep Name | sed 's,[ \t]*Name: ,,g')
    AD_NAMES_PHY=$($ADB devices | grep -v "List of devices attached" | egrep -v -e "emulator-[0-9]{3}" | awk ' { print $1}')
#    AD_NAMES="$AD_NAMES_AVD $AD_NAMES_PHY"
    for AD_NAME_LONG in $AD_NAMES_AVD
    do
	list_android_machines_print_info $AD_NAME_LONG "virtual"
    done
    for AD_NAME_LONG in $AD_NAMES_PHY
    do
	list_android_machines_print_info $AD_NAME_LONG "physical"
    done

}

list_machines()
{
    debug "Listing available machines:"
    echo "Available machines:"
    echo " VirtualBox"
    list_vbox_machines
    echo " Android"
    list_android_machines
}

list_clients()
{
    debug_enter "Listing available clients"

    echo "Available clients:"
    for d in $ETC_DIRS
    do
        debug_enter " entering dir $d"
        debug " in dir $d"
        for i in $(find $d/clients -name "*.conf" 2>/dev/null)
        do
         debug_enter " using file $i"
         debug " file: $i"
         TYPE=$(grep VM_TYPE "$i" | sed 's,[ ]*VM_TYPE=,,g' | sed 's,\",,g')
         echo -n " "
         printf "%s " $(basename $i | sed 's,\.conf,,g' )
         printf " [%.12s] ($i)\n" $TYPE
         debug_leave " "
        done
        debug_leave " "
    done

    debug_leave "list_clients"
}

list_running_vbox()
{
    echo " VirtualBox"
    VB_NAMES=$(vboxmanage list runningvms | awk 'BEGIN { FS="\""} { printf "%s;", $2}' | sed 's,\",,g' )
    SAVED_IFS=$IFS
    export IFS=";"

    if [ "$VB_NAMES" != "" ]
    then
        for VB_NAME in $VB_NAMES
        do
         if [ "$VB_NAME" != "" ]
         then
                IFS=$SAVED_IFS
                CONF_CLIENT=$(find $ETC_DIRS -name *.conf 2>/dev/null | grep "clients/" | xargs grep -l $VB_NAME)
                if [ "CONF_CLIENT" != "" ]
                then
                 VB_SHORT_NAME=$(basename $CONF_CLIENT | sed 's,\.conf,,g')
                  echo " |--$VB_SHORT_NAME [$CONF_CLIENT] (machine: $VB_NAME )"
                fi
         fi
        done
    else
        echo " No virtualbox machines is currently running."
    fi
    IFS=$SAVED_IFS
}

list_running_android()
{
    echo "  Android"

    AD_NAMES=$(get_connected_avds | awk '{ printf "%s;", $1}' )

    export IFS=";"
    if [ "$AD_NAMES" != "" ]
    then
	for AD_NAME in $AD_NAMES
	do
	    
	    if [ "$(echo $AD_NAME | egrep -v -e "emulator-[0-9]{3}" | wc -l)" =  "0" ]
	    then
		AD_PORT=$(echo $AD_NAME | sed 's,emulator-,,g')
		AVD_NAME=$(get_avd_name_for_port $AD_PORT)
	    else
		AVD_NAME="$AD_NAME"
	    fi

	    FOUND=0
	    for dir in $(echo $ETC_DIRS | sed 's, ,;,'g)
	    do
		if [ -d ${dir}/clients ]
		then
		    for vb in $(find ${dir}/clients -name *.conf | xargs grep -l $AVD_NAME )
		    do
			VB_SHORT_NAME=$(basename $vb | sed 's,\.conf,,g')
			echo "  |--$VB_SHORT_NAME  [$vb] (machine: $AVD_NAME))"  
			FOUND=1
		    done
		fi
	    done
	done
    else
	echo "   no android emulators currently running"
    fi
}

list_running_android_machines()
{
    echo "  Android"

    AD_NAMES=$(get_connected_avds | awk '{ printf "%s;", $1}' )

    export IFS=";"
    if [ "$AD_NAMES" != "" ]
    then
	for AD_NAME in $AD_NAMES
	do
	    
	    if [ "$(echo $AD_NAME | egrep -v -e "emulator-[0-9]{3}" | wc -l)" =  "0" ]
	    then
		AD_PORT=$(echo $AD_NAME | sed 's,emulator-,,g')
		AVD_NAME=$(get_avd_name_for_port $AD_PORT)
		PORT_STRING="(using port $AD_PORT)"
	    else
		PORT_STRING=" (physical device)"
		AVD_NAME="$AD_NAME"
	    fi

	    echo "  |-- $AVD_NAME $PORT_STRING"
	    
	    FOUND=0
	    for dir in $(echo $ETC_DIRS | sed 's, ,;,'g)
	    do
#		echo "------ 1"
		if [ -d ${dir}/clients ]
		then
#		echo "------ 2: ${dir}/clients  BEGIN"
#		find ${dir}/clients -name "*.conf" | xargs grep -l $AVD_NAME | awk 'BEGIN { printf "%s;", $0}'
#		echo "------ 2: ${dir}/clients  MID   $AVD_NAME"
		    for ad in $(find ${dir}/clients -name "*.conf" | xargs grep -l "$AVD_NAME" |  awk ' { printf "%s;", $0}')
		    do
#			echo " ---3 :::  looked for \"$ad\" ..."
			VB_SHORT_NAME=$(basename $ad | sed 's,\.conf,,g')
			echo "    |--$VB_SHORT_NAME  [$ad] (machine: $AVD_NAME))"  
			FOUND=1
		    done
#		echo "------ 2: ${dir}/clients  END   $AVD_NAME"

		fi
	    done
	    if [ $FOUND -eq 0 ] ;
	    then
	        echo " * avd is not registered as Testingmachine machine" ;
	        echo " * to create a configuration file, try: --create-client-conf $AVD_NAME" ;
	    fi

	done
    else
	echo "   no android emulators currently running"
    fi


}


list_running_vbox_machines()
{
    echo "  VirtualBox"
    VB_NAME=$(vboxmanage list runningvms | awk ' { printf "%s", $1}' | sed 's,\",,g')
    if [ "$VB_NAME" != "" ]
    then
        SAVED_FS=$IFS
            export IFS=";"
        for i in $VB_NAME
        do
            echo "  |--$i  "
            FOUND=0
            for dir in  $(echo $ETC_DIRS | sed 's, ,;,'g)
            do
                if [ -d $dir ]
                then
                    for vb in $(find $dir/clients -name *.conf | xargs grep -l $i )
                    do
                        VB_SHORT_NAME=$(basename $vb)
                        echo "    |--$VB_SHORT_NAME  [$vb] (client)"  
                        FOUND=1
                    done
                fi
            done
            if [ $FOUND -eq 0 ] ; then echo "    * vbox is not in use"; fi
        done
        IFS=$SAVED_IFS
    else
        echo "   no virtualbox machines currently running"
    fi
}


list_running_clients()
{
    echo "Running clients:"
    list_running_vbox
    list_running_android
}

list_running_machines()
{
    echo "Running machines:"
    
    list_running_vbox_machines
    list_running_android_machines
}

start_client()
{
    WANTED_CLIENT="$1"
    START_ARGS="$2"

    debug "start_client: calling         start_helper ($WANTED_CLIENT, $VM_TYPE, $CLI_CONF, $START_ARGS)"
    start_helper "$WANTED_CLIENT" "$VM_TYPE" "$CLI_CONF" "$START_ARGS"
    return $?
}

start_helper()
{
    debug "start_helper: $*"

    WANTED_CLIENT=$1
    VM_TYPE=$2
    CLI_CONF=$3
    START_ARGS=$4

    case $VM_TYPE in
        "VirtualBox")
         debug "Starting vbox \"$WANTED_CLIENT\" ($START_ARGS)"
         if [ "$START_ARGS" = "headless" ]
         then
                start_vbox_headless $VM_NAME
                RET=$?
         else
                start_vbox $VM_NAME
                RET=$?
         fi

         if [ $RET -ne 0 ]
                then
                debug "Failed to start \"$VM_NAME\"."
                echo "Failed to start \"$VM_NAME\"."
                return 1
         fi

         check_vbox_proc $VM_NAME
         RET=$?
        
         if [ $RET -ne 0 ]
         then
             OK=0
         else
             OK=1
         fi
# Shouldn't be removed???
#        OK=$?
         log "$OK" "Start VirtualBox" "$VM_NAME"
         ;;

        "Android")
         debug "Starting android \"$WANTED_CLIENT\" ($START_ARGS)."
         if [ "$START_ARGS" = "headless" ]
         then
                start_android_headless $VM_NAME
                sleep 2
         else
                start_android $VM_NAME
                sleep 2
         fi
         ;;

        "qemu")
         debug "Starting qemu \"$WANTED_CLIENT\"."
         start_qemu "$WANTED_NAME" "&"

         check_qemu_proc $VM_NAME
         RET=$?
         
         if [ $RET -ne 0 ]
         then
             OK=0
         else
             OK=1
         fi
# Shouldn't be removed???
#        OK=$?
         log "$OK" "Start qemu" "$VM_NAME"
         ;;

        *)
         echo "Failed finding vm type for \"$WANTED_CLIENT\"."
         log "1" "Unknown vm type" "$VM_NAME"
         exit
         ;;
    esac
# Shouldn't be removed??? $2 == $VM_TYPE
    # if [ "$2" = "--no-wait" ]
    # then
    #     return 0
    # fi

    wait_until_up $VM_NAME
}

start_vbox()
{ # Why rename  VM_NAME and then export???
    export PROC_EXPR=$1

    debug "Start vbox \"$VM_NAME\"."

    if [ $(vboxmanage list vms | grep -c "$PROC_EXPR" | wc -l) -eq 0 ]
    then
        debug "Could not find vbox image \"$PROC_EXPR\"."
        return 1
    fi
    ERR_FILE=$TM_TMP_FILE_DIR/$$.vbm-err
    rm -f $ERR_FILE
    VBoxManage startvm "$VM_NAME" 2> $ERR_FILE >/dev/null &
    sleep 3
# Isn't ERR_FILE empty? because >/dev/null, change to 2>/dev/null?
    ERROR_FOUND=$(grep -e "error" $ERR_FILE | grep -e "exit code" | wc -l)
    if [ "$ERROR_FOUND" != "0" ]
    then
        debug "Could not start vbox. Error message:"
        debug "$(cat $ERR_FILE)"
        rm -f $ERR_FILE
        return 1
    fi
    rm -f $ERR_FILE
    maximise_vbox "$VM_NAME"
    return 0
}

start_vbox_headless()
{
    if [ $(vboxmanage list vms | grep "$VM_NAME" | wc -l) -eq 0 ]
        then
        debug "Could not find vbox image: $VM_NAME"
        return 1
    fi
    debug "start_vbox_headless()"
    debug "start_vbox_headless: vboxheadless -s \"$VM_NAME\""
    ERR_FILE=$TM_TMP_FILE_DIR/$$.vbm-err
    rm -f $ERR_FILE
    vboxheadless -s "$VM_NAME" 2> $ERR_FILE >/dev/null &

    if [ "$ANDROID_SYS" = "" ]
    then   
    	   echo "Not starting AVD....since we have no ANDROID_SYS"
	   return
    fi	

    sleep 5
    ERROR_FOUND=$(grep -i -e "error" $ERR_FILE | wc -l)

    if [ "$ERROR_FOUND" != "0" ]
    then
        debug "Could not start vbox (headless). Error message:"
        debug "$(cat $ERR_FILE)"
        rm -f $ERR_FILE
        return 1
    fi

    
    $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS -avd $PROC_EXPR  -netspeed full -netdelay none &
    rm -f $ERR_FILE

    return 0
}

start_android()
{
    debug "start_android."
    export PROC_EXPR=$1

    if [ ! -x $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS ] ; then
	debug "Could not find $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS."
        echo "Android commands doesn't seem to be set up correctly."
        echo "Could not find $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS."
        return 1
    fi

    $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS -avd $PROC_EXPR -netspeed full -netdelay none &
}

start_android_headless()
{
    debug "Start android \"$1\" in headless mode."
    export PROC_EXPR=$1

    if [ ! -x $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS ] ; then
        echo "Android commands doesn't seem to be set up correctly."
        echo "Could not find $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS"
        return 1
    fi

    $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS -avd $PROC_EXPR -netspeed full -netdelay none -no-window &
}

start_qemu()
{
    VM_NAME="$1"

    set_qemu_program $QEMU_CPU

    debug "Starting qemu $1"
    debug " $VM_START_ARGS"
    MONITOR_ARGS="-monitor unix:/tmp/qemu-$VM_NAME.sock,server,nowait "
    REDIR_ARGS="-redir tcp:$SSH_PORT::22 "
    EXTRA_ARGS="-no-reboot -nographic -display none "
    
    START_VM="$QEMU_BINARY -M versatilepb -m 256"
    START_VM="$START_VM -kernel $QEMU_KERNEL -hda $QEMU_HDA"
    START_VM="$START_VM -append \"root=/dev/sda1\" "
    START_VM="$START_VM -initrd $QEMU_INITRD"
    START_VM="$START_VM $MONITOR_ARGS $REDIR_ARGS $EXTRA_ARGS"

    if [ ! -f $QEMU_KERNEL ] || [ ! -f $QEMU_INITRD ] || [ ! -f $QEMU_HDA ]
        then
        debug "Can't find either of:"
        debug " kernel: $QEMU_KERNEL"
        debug " initrd: $QEMU_INITRD"
        debug " hda: $QEMU_HDA"
        return 1
    fi

    if [ "$VNC_PORT" != "" ]
    then
        START_VM="$START_VM -vnc :$VNC_PORT"
    fi
    debug " $START_VM"        
    echo "$START_VM" | bash &
    
    return 0
# /dev/null
}

set_qemu_program()
{
    WANTED_CPU=$1
    export QEMU_BINARY
    case $WANTED_CPU in
        "arm")
         QEMU_BINARY=qemu-system-arm
         ;;
        *)
         echo "Unsupported cmou $WANTED_CPU"
         ;;
    esac
}

check_qemu_proc()
{
    PROC_EXPR=$1
    RET=$(ps auxww | grep qemu | grep -c $PROC_EXPR )

    debug "Number of qemu processes: $RET"
    
    return $RET
}

check_android_proc()
{
    PROC_EXPR=$1
    RET=$(ps auxww | grep emulator | grep -c $PROC_EXPR )

    debug "Number of Android processes: $RET."
    
    return $RET
}

check_vbox_proc()
{
    PROC_EXPR=$1
    RET=$(ps -u `whoami` awww | grep -i virtualbox | grep -c $PROC_EXPR )

    debug "Number of vbox processes: $RET"
    
    return $RET
}

maximise_vbox()
{
    VN_NAME=$1

    debug "Will try to maximise VirtualBox window"
    CTR=0
    WIN_ID=""

    export WMCTRL=$(which wmctrl)

    if [ "$WMCTRL" = "" ]
    then
        echo "Command wmctrl missing on host"
        echo "Cannot maximise the window"
        debug "Command wmctrl missing on host"
        debug "Cannot maximise the window"
        return 1
    fi

    while [ "$WIN_ID" = "" ]
    do
        debug "Waiting for VirtualBox window to appear"
        countdowner 5
        WIN_ID=$($WMCTRL -l | grep VirtualBox | grep -v Manager | grep $VM_NAME | awk ' { print $1}')
        CTR=$(( $CTR + 1))
        debug " current id:$WIN_ID"
        if [ $CTR -gt 10 ]
        then
         debug " We've been waiting long enough"
         RET=1
         break
        fi
    done
    
    if [ "$WIN_ID" != "" ]
    then
        debug "Maximising window: $WIN_ID"
        sleep 2
        $WMCTRL -i -r $WIN_ID -b add,maximized_vert,maximized_horz
        RET=$?
    fi

    return $RET
}

kill_vb_proc()
{
    VB_NAME="$1"
    KILL_ARG=$2

    debug "Kill vb proc $1 ($KILL_ARG)"

    sleep 5
    VBID=$(ps auxww | grep -i virtualbox | grep -v grep | grep $VB_NAME | awk ' { print $2 }')
    if [ "$VBID" != "" ]
        then
        debug "Still a vbox id to slay.. kill $KILL_ARG $VBID"
        kill $VBID 2>/dev/null
    fi
}

# Not in use. Should it be removed?
kill_android()
{
    VB_NAME=$1
    VB_NAME=$(grep VM_NAME $i | sed -e 's,VM_NAME=,,g' -e 's,\",,g' )
    if [ "$VB_NAME" != "" ]
    then
        # Should we use `kill_android_proc'?
        kill_vb_proc "$VB_NAME"
        kill_vb_proc "$VB_NAME" "-9"
    fi
}

kill_vbox()
{
    VB_NAME=$1
    if [ "$VB_NAME" != "" ]
    then
        kill_vb_proc "$VB_NAME"
        kill_vb_proc "$VB_NAME" "-9"
    fi
}

stop_vbox()
{
    VM_NAME=$1
    debug "stop_vbox: \"$VM_NAME\"."

    if [ "$VM_NAME" != "" ]
    then
        is_vbox_up $VM_NAME
        RET=$?

        if [ "$RET" != "0" ] ; then
            debug " sending acpipowerbutton off to $VM_NAME"
            # Press ACPI powerbutton off
	    VBoxManage controlvm $VM_NAME acpipowerbutton off 2>/dev/null
            wait_until_down $VM_NAME
        else
            return 0
        fi

        is_vbox_up $VM_NAME
        RET=$?

        if [ "$RET" != "0" ]
        then
            debug "Power on still after pressing ACPI power off."
            debug "Do a \"hard\" poweroff to \"$VM_NAME\" ."
            VBoxManage controlvm $VM_NAME poweroff 2>/dev/null
            wait_until_down $VM_NAME
	else
	    return 0
        fi
        debug "then this happens"
    fi
}


stop_qemu()
{
    VB_NAME=$1
    debug "Stopping qemu $VM_NAME"

    if [ "$VB_NAME" != "" ]
    then
        debug "Send to QEMU $VB_NAME: ctrl-alt-delete"
        send_to_qemu $VB_NAME "sendkey ctrl-alt-delete"
        wait_for_state down 20 $VB_NAME

        is_qemu_up $VB_NAME
        RET=$?
        if [ "$RET" != "0" ]
        then
         debug " client is up, returning"
         return
        fi

        debug "Send to QEMU $VB_NAME: system_powerdown"
        send_to_qemu $VB_NAME "system_powerdown"
        wait_for_state down 20 $VB_NAME

        is_qemu_up $VB_NAME
        RET=$?
        if [ "$RET" != "0" ]
        then
         debug " client is up, returning"
         return
        fi

        debug "Send to QEMU $VB_NAME: quit"
        send_to_qemu $VB_NAME "quit"
        wait_for_state down 20 $VB_NAME

        break
    fi
}

stop_android()
{
    VB_NAME=$1
    debug "Stopping Android $VM_NAME"

    if [ "$VB_NAME" != "" ]
    then
        debug "Killing Android \"$VB_NAME\"."
        $ADB -s emulator-$ANDROID_PORT emu kill >/dev/null 2>/dev/null

        wait_for_state down 20 $VB_NAME

        is_android_up $VB_NAME
        RET=$?
        if [ "$RET" != "0" ]
        then
         debug " client is up, returning $RET"
        fi
        return $RET
    fi
}

stop_helper()
{
    WANTED_VM=$1
    VM_TYPE=$2
    CLI_CONF=$3

    debug "stop_helper: $WANTED_VM"

    is_client_ssh_up
    RET=$?

    if [ "$RET" = "0" ]
    then
        if [ "$VM_SUPERUSER" != "" ] && [ "$SSH_SHUTDOWN_COMMAND" != "" ]
        then
         debug "Super user account available"
         debug " trying to stop via ssh"
         $SSH $SSH_TEST_OPTIONS -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS $SSH_SHUTDOWN_COMMAND
         RET=$?
         if [ "$RET" != "0" ]
         then
                debug "Failed stopping client with ssh"
                debug " Command: $SSH $SSH_TEST_OPTIONS -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS $SSH_SHUTDOWN_COMMAND"
         else
                wait_until_down $WANTED_VM
         fi
        else
         debug "Missing credentials to stop via ssh and super user"
        fi
    else
        debug "Host \"$WANTED_VM\" ssh seems down, or the vm is not registered as a client"
        debug "Stop \"$WANTED_VM\" using virtual machine ($VM_TYPE)"

        case $VM_TYPE in
            "VirtualBox")
                debug "Stopping vbox \"$WANTED_VM\""
		stop_vbox $WANTED_VM
                kill_vbox $WANTED_VM
                check_vbox_proc $WANTED_VM

                RET=$?
                log "$RET" "Stop VirtualBox" "$VM_NAME"
                return $RET
                ;;

            "qemu")
                debug "Stoping qemu $WANTED_VM"
                stop_qemu "$WANTED_VM"

                check_qemu_proc $1
                RET=$?
                log "$RET" "Stop qemu" "$VM_NAME"
                return $RET
                ;;

            "Android")
                debug "Stoping Android $WANTED_VM"
                stop_android "$WANTED_VM"

                check_android_proc $1
                RET=$?
                log "$RET" "Stop Androd" "$VM_NAME"
                return $RET
                ;;

            *)
                echo "Failed finding vm type for $1"
                exit 123
                ;;
        esac
    fi
}

stop_client()
{
    WANTED_CLIENT=$1
    START_ARGS=$2

    debug "stop_helper ($VM_NAME, $VM_TYPE, $CLI_CONF)"
    stop_helper $VM_NAME $VM_TYPE $CLI_CONF
    return $?
}

pause_helper()
{
    WANTED_VM=$1
    VM_TYPE=$2
    CLI_CONF=$3

    debug "pause_helper: $VM_NAME"

    if [ "$CLI_CONF" != "" ]
    then
        debug "Reading client conf $CLI_CONF"
        . $CLI_CONF
    fi

    debug "Pause $1 using virtual machine ($VM_TYPE)"

    case $VM_TYPE in
        "VirtualBox")
         debug "Pausing vbox $1"
         VBoxManage controlvm $VM_NAME pause
#sleep 10 ; VBoxManage controlvm Ubuntu-12.04 pause ; sleep 600 ; VBoxManage controlvm Ubuntu-12.04 resume ; ssh -p 9022 root@localhost ntpdate-debian         kill_vbox $1
         ;;

        "Android")
            echo "Can't pause Android yet!"
         return 1
         ;;

        "qemu")
            echo "Can't pause qemus yet!"
         return 1
         ;;

        *)
         echo "Failed finding vm type for $1"
         exit 123
         ;;
    esac
}

resume_helper()
{
    WANTED_VM=$1
    VM_TYPE=$2
    CLI_CONF=$3

    debug "resume_helper: $VM_NAME"

    if [ "$CLI_CONF" != "" ]
    then
        debug "Reading client conf $CLI_CONF"
        . $CLI_CONF
    fi

    debug "Resume $1 using virtual machine ($VM_TYPE)"

    case $VM_TYPE in
        "VirtualBox")
         debug "Resuming vbox $1"
         VBoxManage controlvm $VM_NAME resume
         printf "\n\n\t*****RESET TIME LATER!!!!\n\n\n"
#sleep 10 ; VBoxManage controlvm Ubuntu-12.04 pause ; sleep 600 ; VBoxManage controlvm Ubuntu-12.04 resume ; ssh -p 9022 root@localhost ntpdate-debian         kill_vbox $1
         ;;

        "qemu")
            echo "Can't pause qemus yet!"
         return 1
         ;;

        *)
         echo "Failed finding vm type for $1"
         exit 123
         ;;
    esac
}

pause_client()
{
    WANTED_VM=$1
    START_ARGS=$2

    debug "pause_helper ($WANTED_VM, $VM_TYPE, $CLI_CONF)"
    pause_helper $WANTED_VM $VM_TYPE $CLI_CONF
    return $?
}

resume_client()
{
    WANTED_VM=$1
    START_ARGS=$2

    debug "resume_helper ($WANTED_VM, $VM_TYPE, $CLI_CONF)"
    resume_helper $WANTED_VM $VM_TYPE $CLI_CONF
    return $?
}


find_vm_type()
{
    VM_NAME=$1
    
    VBOX_FOUND=$(vboxmanage list vms | awk ' BEGIN { FS="\""} { print $2 } ' | sed 's,\",,g' | grep -w $VM_NAME | wc -l)

    ANDROID_FOUND=$(list_android_machines | grep -w $VM_NAME | wc -l)

    debug "find_vm_type: VBOX_FOUND: $VBOX_FOUND"
    debug "find_vm_type: ANDROID_FOUND: $ANDROID_FOUND"

    if [ $VBOX_FOUND -ne 0 ]
    then
        export VM_TYPE="VirtualBox"
    elif [ $ANDROID_FOUND -ne 0 ]
    then
        export VM_TYPE="Android"
    fi
}

start_client_wait_for_ssh()
{
    auto_debug "Starting client $CLIENT_NAME"
    $VMM_CLIENT --start-client $CLIENT_NAME
    
    auto_debug "Wait for ssh"
    $VMM_CLIENT --wait-for-ssh $CLIENT_NAME 300
    RET=$?

    return $RET
}


is_qemu_up()
{
    export WANTED_VM=$1

    CNT=$(send_to_qemu $WANTED_VM "info status" | grep "VM status: running" | wc -l)

    debug " is_qemu_up: $CNT"

    # If the VM is running (>1), return 0
    if [ $CNT -ne 0 ]
    then
        debug "qemu vm \"$WANTED_VM\" is running."
        return 0
    fi

    debug "qemu vm \"$WANTED_VM\" is NOT running."
    return 1
}

is_vbox_up()
{
    export WANTED_VM=$1

    debug " is_vbox_up? "

    CNT=$(vboxmanage list runningvms | awk 'BEGIN { FS="\""} { print $2 } ' | sed 's,\",,g' | grep $WANTED_VM | wc -l)
    
    debug " is_vbox_up: $CNT"

    # If the VM is running (>1), return 0
    if [ $CNT -eq 1 ]
    then
        debug "vbox vm \"$WANTED_VM\" is running."
        return 0
    fi

    debug "vbox vm \"$WANTED_VM\" is NOT running."
    return 1
}

is_android_up()
{
    export WANTED_VM=$1

    if [ ! -x $ADB ] ; then
        echo "Android commands doesn't seem to be set up correctly."
        echo "Could not find adb."
        return 1
    fi

    if [ "$ANDROID_PORT" = "" ] ;
    then
        sleep 3
        get_android_specific_info $WANTED_VM
    fi

    debug " is_android_up? adb -s emulator-$ANDROID_PORT shell ls"
    $ADB -s emulator-$ANDROID_PORT shell ls >/dev/null 2>/dev/null
    RET=$?
    
    debug " is_android_up: $RET"

    # If the VM is NOT running (!=0), return 1
    if [ $RET -ne 0 ]
    then
        debug "Android avd \"$WANTED_VM\" is NOT running."
        return 1
    fi

    debug "Android avd \"$WANTED_VM\" is running."
    return 0
}


is_client_up()
{
    WANTED_VM=$1

    case $VM_TYPE in
        "VirtualBox")
            is_vbox_up $WANTED_VM
            RET=$?
            ;;

        "Android")
            is_android_up $WANTED_VM
            RET=$?
            ;;

        "qemu")
            is_qemu_up $WANTED_VM
            RET=$?
            ;;

        *)
	    debug "Failed finding vm type for \"$WANTED_VM\"."
            echo "Failed finding vm type for \"$WANTED_VM\"."
            exit 123
            ;;
    esac
    
    debug "is_client_up ($WANTED_VM, $VM_TYPE) => $RET"
    return $RET
}

is_client_ssh_up()
{
    debug "Check if Client ssh server is up"
    debug " ssh: $SSH"
    debug " options: $SSH_TEST_OPTIONS"
    debug " port: -p $SSH_PORT"
    debug " user $VM_USER@$VM_IP_ADDRESS"
    debug " command: exit"
    $SSH $SSH_TEST_OPTIONS \
        -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS exit \
         2>/dev/null
    RET=$?
    debug " Returning: $RET"
    return $RET
}

is_client_x11_up()
{
    WANTED_VM=$1

    case $VM_TYPE in
        "VirtualBox")
         debug "Check if Client X11 is up"
         exec_client_command $1 "DISPLAY=:0 xdpyinfo 2>/dev/null >/dev/null 2>/dev/null "
         RET=$?
         ;;
        "qemu")
         echo "Can't check X11 on qemu"
         debug "Can't check X11 on qemu"
         RET=1
         ;;
        "Android")
         echo "Can't check X11 on Android"
         debug "Can't check X11 on Android"
         RET=1
         ;;
        *)
         debug " Unknown vm type"
         echo "Failed finding vm type for $1"
         RET=1
         ;;
    esac

    debug "is_client_x11_up Returning: $RET"
    return $RET
}

is_client_online()
{
    if [ "$VM_TYPE" = "VirtualBox" ]
    then
        echo "Check if Vbox client is online"
        debug " ssh: $SSH"
        debug " options: $SSH_TEST_OPTIONS"
        debug " port: -p $SSH_PORT"
        debug " user $VM_USER@$VM_IP_ADDRESS"
        debug " command: ping -c1 www.google.com"

        $SSH $SSH_TEST_OPTIONS \
            -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS ping -c1 www.google.com \
            > /dev/null

        RET=$?
    fi

    if [ "$VM_TYPE" = "Android" ]
    then

        ANDROID_PORT=$(get_avd_port_for_name $1)
        echo "Check if Android client is online"

        debug " client: $1"
        debug " adb: $ADB"
        debug " port: $ANDROID_PORT"
        debug " command: ping -c1 www.google.com"

        $ADB -s emulator-$ANDROID_PORT shell ping -c1 www.google.com > /dev/null

        RET=$?
    fi

    debug " Returning: $RET"
    if [ "$RET" = "0" ]
    then
    ## printf probably a little silly here
        printf " Google can be reached...\n"
    else
        printf " Google can NOT be reached...\n"
    fi

    return $RET
}

# eGov specific, is service actually online, if not abort...
#is_egovonline()
#{
# if ping -c1 account.egov.bz.it > /dev/null
# then echo "eGov online..."
# else
# echo "Abort, server nor reachable"
# fi
#}

wait_for_ssh()
{
    EXPECTED_STATE="$1"
    TIMEOUT=$2
    CLIENT=$3

    debug "Will wait for (ssh) $1 for $2 seconds"
    
    TIMEDOUT=false
    START_SECS=$(date "+%s")
    # Set to a negative integer value
    DIFF=-12

    while [ "$TIMEDOUT" = "false" ]
    do
        BREAK=false

        debug " Check if client is up: "

        is_client_ssh_up
        RET=$?
        if [ "$EXPECTED_STATE" = "up" ]
        then
         if [ "$RET" = "0" ]
         then
                BREAK=true
         elif [ "$RET" != "0" ]
         then
                BREAK=false
         fi
        # elif [ "$EXPECTED_STATE" = "down" ] ? in future ?
        # then
        fi

        debug " Should we break? $BREAK "

        if [ "$BREAK" = "true" ]
        then
         break
        fi

        sleep 10
        CURRENT=$(date "+%s")
        DIFF=$(( $START_SECS + $TIMEOUT - $CURRENT))
        debug " Started: $START_SECS Current: $CURRENT Timeout: $TIMEOUT"
        debug " Diff: $DIFF"

        if [ $DIFF -le 0 ]
        then
         TIMEDOUT=true
        fi
        debug " have we timed out? $TIMEDOUT "
    done
    debug "timeout or state reached ... continuing"
}

wait_until_up()
{
    # Set timeout in case it's not set. Move to defaults?
    if [ "$VM_STARTUP_TIMEOUT" = "" ]
    then
        VM_STARTUP_TIMEOUT="10"
    fi
    wait_for_state up $VM_STARTUP_TIMEOUT $1
}

wait_until_down()
{
    # Set timeout in case it's not set. Move to defaults?
    if [ "$VM_STOP_TIMEOUT" = "" ]
    then
        VM_STOP_TIMEOUT="20"
    fi
    wait_for_state down $VM_STOP_TIMEOUT $1
}

wait_for_state()
{
    EXPECTED_STATE="$1"
    TIMEOUT=$2
    VB_NAME=$3

    debug "Will wait vm \"$VB_NAME\" for \"$1\" for \"$2\" seconds."
    
    TIMEDOUT=false
    START_SECS=$(date "+%s")
    # Set to a negative integer value
    DIFF=-12

    while [ "$TIMEDOUT" = "false" ]
    do
        BREAK=false

        debug "Check if client is up: "

        is_client_up $VB_NAME
        RET=$?

        # Break waiting when the client is up.
        if [ "$EXPECTED_STATE" = "up" ]
        then
            if [ "$RET" = "0" ]
            then
                BREAK=true
		debug "\"$WANTED_VM\" is running."
		echo "\"$WANTED_VM\" is running."
            else
                BREAK=false
		debug "\"$WANTED_VM\" is not running yet."
            fi
        # Break waiting when the client is down.
        elif [ "$EXPECTED_STATE" = "down" ]
        then
            if [ "$RET" = "0" ]
            then
                BREAK=false
		debug "\"$WANTED_VM\" is still running."
            else
                BREAK=true
		debug "\"$WANTED_VM\" is shut down."
		echo "\"$WANTED_VM\" is shut down."
            fi
        fi

        debug " Should we break? $BREAK "

        if [ "$BREAK" = "true" ]
        then
            break
        fi

        sleep 10
        CURRENT=$(date "+%s")
        DIFF=$(( $START_SECS + $TIMEOUT - $CURRENT ))
        debug " Started: $START_SECS Current: $CURRENT Timeout: $TIMEOUT"
        debug " Diff: $DIFF"

        if [ $DIFF -le 0 ]
        then
            TIMEDOUT=true
        fi
        debug "Have we timed out? $TIMEDOUT "
    done
    debug "Timeout or state reached ... continuing"
}

send_to_qemu()
{
    WANTED_VM=$1
    MSG=$2
    echo "$MSG" | socat - unix-connect:/tmp/qemu-${WANTED_VM}.sock 2>/dev/null | \
          grep -v "(qemu)" | grep -v "QEMU [0-9\. ]*monitor"
}

check_status_helper()
{
    WANTED_VM=$1
    VM_TYPE=$2
    CLI_CONF=$3

    debug "Check status of \"$WANTED_VM\"."

    CLI_CONF=$i
    debug "Reading client conf $CLI_CONF"
    . $CLI_CONF
    

    case $VM_TYPE in
        "VirtualBox")
         debug " check status with vbox"
         is_vbox_up "$VM_NAME"
         RET=$?
         debug " status: $RET"
         return $RET
         ;;
        "Android")
         debug " check status with android"
         check_client_android "$WANTED_VM"
#> /dev/null
         RET=$?
         debug " status: $RET"
         return $RET
         ;;
        "qemu")
         debug " check status with qemu"
         send_to_qemu "$WANTED_VM" "info status" > /dev/null
         RET=$?
         debug " status: $RET"
         return $RET
         ;;
        *)
         debug " Unknown vm type"
         echo "Failed finding vm type for $1"
         exit 123
         ;;
    esac

    return $RET
}

check_client_ssh()
{
    WANTED_VM=$1

    echo -n "Client \"$WANTED_VM\" ssh connection: "
    debug "Check ssh connection for \"$WANTED_VM\"."
    check_ssh_helper $WANTED_VM $VM_TYPE $CLI_CONF
    RET=$?
    debug " status: $RET"
    return $RET
}

check_ssh_helper()
{
    VM_NAME=$1
    VM_TYPE=$2
    CLI_CONF=$3

    debug "Check ssh of \"$VM_NAME\"."
    debug "ssh: $SSH option: $SSH_TEST_OPTIONS -p port: $SSH_PORT user: $VM_USER address: $VM_IP_ADDRESS"
    $SSH $SSH_TEST_OPTIONS -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS exit \
        2>/dev/null >/dev/null
    RET=$?
    
    if [ $RET -ne 0 ]
    then
        echo "not available"
        debug " $VM_NAME down or not responding"
    else
        debug " $VM_NAME is ok"
        echo "ok"
    fi

    return $RET
}

check_client_status()
{
    WANTED_VM="$1"

    debug "Checking status of $1"

    echo -n "Client \"$WANTED_VM\" status: "
    check_status_helper "$WANTED_VM" "$VM_TYPE" "$CLI_CONF"
    RET=$?
    if [ "$RET" = "0" ]
    then
        echo "running"
        return 0
    fi
    echo "not running"

    return $RET
}

print_client()
{
    WANTED_VM=$1

    for d in $ETC_DIRS
    do
        for i in $(find $d/clients -name "$1.conf" 2>/dev/null)
        do
         CLI_CONF=$i
         echo "Configuration file: $CLI_CONF"
         cat $CLI_CONF
        done
    done
}

exec_client_command()
{
    WANTED_VM=$1
    COMMAND="$2"
    ON_FAIL="$3"

    debug "exec_client_command $1 $2"

    if [ "$VM_TYPE" = "VirtualBox" ]
    then
        debug "$SSH -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS $COMMAND"
        $SSH -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS \
            "$COMMAND"
        RET=$?
    elif [ "$VM_TYPE" = "Android" ]
    then
	exec_client_command_android $1 $ANDROID_PORT "$COMMAND"
	RET=$?
    else
        echo "exec_client_command(): support for \"$VM_NAME\" not implemented yet!"
        RET=1
    fi

    return $RET
}

exec_client_command_as_root()
{
    WANTED_VM=$1
    COMMAND="$2"

    debug "exec_client_command $1 $2"
    debug "$SSH -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS $COMMAND"
    $SSH -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS \
        "$COMMAND"
    return $?
}

check_client_android()
{
    AVD_NAME="$1"
    export IFS=";"
    for dir in $(echo $ETC_DIRS | sed 's, ,;,'g)
    do
        if [ -d ${dir}/clients ]
        then
         for vb in $(find ${dir}/clients -name $AVD_NAME.conf )
         do
                AVD_MACHINE=$(grep VM_NAME $vb | sed -e 's,VM_NAME=,,g' -e 's,\",,g')
                check_machine_android $AVD_MACHINE
                RET=$?
                break
         done
        fi
    done
    export IFS=""
    return $RET
}

check_machine_android()
{
    WANTED_VM=$1

    check_android_settings hard
    RET=$?
    if [ $RET -ne 0 ] ; then return $RET; fi

    debug "Trying to find $WANTED_VM among android avds to check for status"
    VB_NAMES=$($ANDROID list avd | grep Name | sed -e 's,[ \t]*Name: ,,g' | tr '\n' ' ')

    SAVED_IFS=$IFS
    export IFS=" "
    for VB_NAME in $VB_NAMES
    do
        FOUND=false
        if [ "$VB_NAME" = "$WANTED_VM" ]
         then
         FOUND=true
         MACHINE_FOUND=true
         AP=$(get_avd_port_for_name $WANTED_VM)
         # Hard to get good info out of adb about avd status
         # check files in root - if not 0 then ok ... ehum
         LS_LEN=$(exec_client_command_android $AP ls 2>/dev/null | wc -l)
         if [ $LS_LEN -gt 0 ]
                then
                RET=0
         else
                RET=1
         fi
        fi
    done

    IFS=$SAVED_IFS

    return $RET
}

get_vbox_specific_info()
{
    WANTED_VM=$1

    if [ "$SSH_PORT" = "auto" ]
    then
        SSH_PORT=$(vboxmanage showvminfo $WANTED_VM 2>/dev/null | grep "NIC" | grep -e Rule -e ssh | grep 22 | grep "host port" | sed 's,[a-zA-Z0-9,: \ =()]*host port[ \t]*=,,g' | cut -d, -f1 )
	return 0
    fi

    if [ "$SSH_PORT" = "" ]
    then
        debug "SSH_PORT is not set."
        return 1
    else
	debug "SSH_PORT is set as $SSH_PORT."
	return 1
    fi
}

get_android_specific_info()
{
    check_android_settings

    WANTED_VM="$1"
    ANDROID_SYS=$( grep ANDROID_SYS $CLI_CONF | sed 's,ANDROID_SYS=,,g' | sed 's,\",,g')
# This function only works when the avd is running/attached.
    ANDROID_PORT=$(get_avd_port_for_name $WANTED_VM)
}

get_vm_specific_info()
{
    WANTED_VM="$1"
    RET=1
    if [ "$VM_TYPE" = "VirtualBox" ]
    then
        get_vbox_specific_info $WANTED_VM
        RET=$?
    elif [ "$VM_TYPE" = "Android" ]
    then
        get_android_specific_info $WANTED_VM
        RET=$?
    else
        echo "get_vm_specific_info(): support for \"$WANTED_VM\" not implemented yet!"
    fi
    return $RET
}

get_info_for_client()
{
    debug "Trying to get info for client \"$1\"."
    WANTED_CLIENT=$1
    CLI_CONF=""
    CONF_FOUND=false

    for ETC_DIR in $ETC_DIRS
    do
        CLI_CONF=$(find $ETC_DIR/clients -name "$WANTED_CLIENT.conf" 2>/dev/null)

	if [ "$CLI_CONF" != "" ] ; then
	    CONF_FOUND=true
            . $CLI_CONF
            export VM_NAME=$(grep VM_NAME $CLI_CONF | sed -e 's,VM_NAME=,,g' -e 's,\",,g' )

            get_vm_specific_info $VM_NAME
            RET=$?
            if [ $RET -ne 0 ] ; then
		debug "Client \"$WANTED_CLIENT\" seems to be down"
		debug "exit tm-vmm."
		exit 1
	    else
		debug "Got client info for \"$WANTED_CLIENT\": $VM_NAME, $VM_TYPE, $CLI_CONF."
		break
	    fi
        fi
    done

    if [ $CONF_FOUND = true ] ; then
	debug "Found .conf file for \"WANTED_CLIENT\"."
	case $VM_TYPE in
	   VirtualBox)
		check_vbox_vm_existence $VM_NAME
		if [ 0 = $? ] ; then
		    debug "vbox machine \"$VM_NAME\" has been found."
		    return 0
		else
		    debug "Couldn't find vbox machine \"$VM_NAME\"."
		    echo "Couldn't find vbox machine \"$VM_NAME\"."
		    exit 1
		fi
		;;

	    Android)
		check_android_vm_existence $VM_NAME
		if [ 0 = $? ] ; then
		    debug "Android machine \"$VM_NAME\" has been found."
		    return 0
		else
		    debug "Can't find android machine \"$VM_NAME\"."
		    echo "Can't find android machine \"$VM_NAME\"."
		    exit 1
		fi
		;;

	    # qemu in the future?

	    *)
		debug "Not implemented for this type of vm yet."
		echo "Not implemented for this type of vm yet."
		exit 1
	esac
    else
	debug "Can't find .conf file for \"$WANTED_CLIENT\"."
	echo "Can't not find .conf file for \"$WANTED_CLIENT\"."

	check_vbox_vm_existence $WANTED_CLIENT
	RET_VBOX=$?
	check_android_vm_existence $WANTED_CLIENT
	RET_ANDROID=$?

	if [ $RET_VBOX = 0 ] ; then
	    if [ $RET_ANDROID = 0 ] ; then
	        # No configation found, multiple virtual machines found, exit 1
		talk_to_user Multi
		exit 1
	    fi
	    # No configuration found, only one vbox vm, continue or exit 0
	    talk_to_user VirtualBox
	    RET=$?

	elif [ $RET_ANDROID = 0 ] ; then
	    # No configuration found, only one android vm, continue or exit 0
	    talk_to_user Android
	    RET=$?
	else
	    debug "Can't find any info for \"$WANTED_CLIENT\". Exits..."
	    echo "Can't find any info for \"$WANTED_CLIENT\". Exits..."
	    RET=1
	fi

	if [ $RET = 0 ] ; then
	    return $RET
	else
	    exit $RET
	fi
    fi
}

talk_to_user()
{
    VM_TYPE=$1

    if [ $VM_TYPE = Multi ] ; then
	echo "There are more than one virtual machine named \"$WANTED_CLIENT\"."
	echo "You have to manually create a configuration file."
	return 1
    else
	echo "There is a $VM_TYPE machine named \"$WANTED_CLIENT\" that does not have a .conf file yet."
	echo -n "To create a configuration file enter \"y\" and press Enter; to quit tm-vmm enter\"n\" and press Enter: "
	while true
	do
	    read ANSWER
	    if [ $VM_TYPE = VirtualBox ] ; then
		if [ $ANSWER = y ] ; then
		    create_vbox_client_conf $WANTED_CLIENT
		    return $?
		elif [ $ANSWER = n ] ; then
		    return 1
		else
		    echo "Invalid input. Try again."
		fi
	    elif [ $VM_TYPE = Android ] ; then
		if [ $ANSWER = y ] ; then
		    create_android_client_conf $WANTED_CLIENT
		    return $?
		elif [ $ANSWER = n ] ; then
		    return 1
		else
		    echo "Invalid input. Try again."
		fi
	    fi
	done
    fi
}

check_vbox_vm_existence()
{
    WANTED_VM=$1
    debug "check_vbox_vm_existence: \"$WANTED_VM\""
    CNT=0

    CNT=$(vboxmanage list vms | grep \"$WANTED_VM\" | wc -l)

    debug "Found $CNT vbox machine."
    if [ $CNT = 1 ] ; then
	return 0
    else
	return 1
    fi
}

check_android_vm_existence()
{
    WANTED_VM=$1
    debug "check_android_vm_existence: \"$WANTED_VM\""
    CNT=0

    CNT=$($ANDROID list avd | grep Name | sed 's,[ \t]*Name: ,,g' | grep "$WANTED_VM" | wc -l)

    debug "Found $CNT Android machine."
    if [ $CNT = 1 ] ; then
	return 0
    else
	return 1
    fi
}

vnc_snapshot()
{
    rm -f tmp.jpg
    vncsnapshot :5 tmp.jpg
}

vbox_snapshot()
{
    
    VBoxManage controlvm $1 screenshotpng "$2"
}

android_snapshot()
{
    check_android_settings hard
    if [ "$?" != "0" ] ; then
        echo "Android commands don't seem to be set up correctly."
        return 1
    fi

    if [ ! -x $ADB ] ; then
        echo "Android commands don't seem to be set up correctly."
        echo "Could not find adb"
        return 1
    fi

    # COmmand line fron http://blog.shvetsov.com/2013/02/grab-android-screenshot-to-computer-via.html
    $ADB -s emulator-$1 shell screencap -p | perl -pe 's/\x0D\x0A/\x0A/g' > $2
}

rename_screenshot_name()
{
    export IMG=$1
    LAST_PIC=$(ls -1t Screenshot-$1-*.jpg | head -1)

    LAST_NR=$(echo $LAST_PIC | sed -e "s,Screenshot-$IMG\-,,g" -e "s,.jpg,,g")

    NEXT_NR=$(( $LAST_NR + 1 ))
    NEXT_NR_STR=$(printf "%.3d" $NEXT_NR)
    
    NEXT_IMG=Screenshot-$1-$NEXT_NR_STR.jpg

    mv tmp.jpg $NEXT_IMG
    
}

client_screenshot()
{
    debug "client_screenshot $VM_NAME"

    if [ ! -d $TM_IMAGE_DIR ] ; then mkdir -p $TM_IMAGE_DIR ; fi
    PIC_NAME=$TM_IMAGE_DIR/image-$VM_NAME-`date +%s`.png

    case $VM_TYPE in
        "VirtualBox")
         vbox_snapshot $VM_NAME $PIC_NAME
         echo "VBOX screenshots not implemented"
         ;;
        "qemu")
         vnc_snapshot > /dev/null 2> /dev/null
         ;;
        
        "Android")
         android_snapshot "$ANDROID_PORT" "$PIC_NAME"
         # > /dev/null 2> /dev/null
         ;;
        
        *)
         echo "Screenshots not implemented for $1"
         ;;
    esac

    if [ -f tmp.jpg ]
    then
        rename_screenshot_name $1
        echo "Stored: \"$NEXT_IMG\""
    else
        echo "Uh oh"
    fi
}


auto_debug()
{
    debug "[$VMM_AUTO_NAME] $*"
}



exec_user_scripts()
{
    TMP=0
    export script=bogus
    while [ "$script" != "" ]
    do
        
        LINE=${SCRIPTS_TO_EXECUTE[$TMP]}
        if [ "$LINE" = "" ] ; then break ; fi
        auto_debug "Executing user supplied script: $script"
        
        TYPE=${LINE:0:9}
        script=${LINE:9}
        
        if [ "$TYPE" = "rem-user:" ]
        then
         echo ${VMM_CLIENT} --client-exec ${CLIENT_NAME} "\"${script}\"" | bash
        elif [ "$TYPE" = "rem-root:" ]
        then
         echo ${VMM_CLIENT} --client-exec-as-root ${CLIENT_NAME} "\"${script}\"" | bash
        else
         ${script}
        fi
        
        RET=$?
        auto_debug "User supplied script ($script)returned: $RET"
        
        if [ $RET -ne 0 ]
        then
         return $RET
        fi
        
        TMP=$(( $TMP + 1 ))
    done



    return 0
}

open_ssh()
{
    $SSH $SSH_TEST_OPTIONS \
        -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS
        
    return $?
}

import_appliance()
{
    OVA_FILE=$1
    if [ ! -f $OVA_FILE ]
    then
        echo "Can't find the ova file $OVA_FILE"
        return 1
    fi

    VBoxManage import "$OVA_FILE"

}

copy_from_client()
{
    MY_SRC_HOST=$1
    MY_SRC_LOC=$2
    MY_DST_LOC=$3

    case $VM_TYPE in
        "VirtualBox")
         echo "copy vbox"
         $SCP -r -P $SSH_PORT $VM_USER@$VM_IP_ADDRESS:$MY_SRC_LOC $MY_DST_LOC
         ;;
    
        "Android")

         check_android_settings hard
         if [ "$?" != "0" ] ; then
                echo "Android commands doesn't seem to be set up correctly."
                return 1
         fi
        
         if [ ! -x $ADB ] ; then
                echo "Android commands doesn't seem to be set up correctly."
                echo "Could not find adb"
                return 1
         fi
         debug "copy android"
         debug " adb -s emulator-$ANDROID_PORT pull $MY_SRC_LOC $MY_DST_LOC"
         $ADB -s emulator-$ANDROID_PORT pull $MY_SRC_LOC $MY_DST_LOC
         ;;
        *)
         echo "copy not supported"
         return 1
         ;;
    esac

    return 0
}


copy_to_client()
{
    MY_SRC_LOC=$1
    MY_DST_HOST=$2
    MY_DST_LOC=$3

    case $VM_TYPE in
        "VirtualBox")
         debug "$SCP -r $MY_SRC_LOC -P $SSH_PORT $VM_USER@$VM_IP_ADDRESS:$MY_DST_LOC"
         $SCP -r -P $SSH_PORT $MY_SRC_LOC $VM_USER@$VM_IP_ADDRESS:$MY_DST_LOC
         ;;
    
        "Android")

         check_android_settings hard
         if [ "$?" != "0" ] ; then
                echo "Android commands doesn't seem to be set up correctly."
                return 1
         fi

         if [ ! -x $ADB ] ; then
                echo "Android commands doesn't seem to be set up correctly."
                echo "Could not find adb"
                return 1
         fi
         debug "copy android"
         debug " adb -s emulator-$ANDROID_PORT push $MY_SRC_LOC $MY_DST_LOC"
         $ADB -s emulator-$ANDROID_PORT push $MY_SRC_LOC $MY_DST_LOC
         ;;
        *)
         echo "copy not supported"
         return 1
         ;;

    esac
    
    return 0
}


client_copy_file()
{
    MY_SRC="$1"
    MY_DST="$2"

    IFS=":"; declare -a MY_SRC_ARR=($MY_SRC)
    SRC_HOST=${MY_SRC_ARR[0]}
    SRC_LOC=${MY_SRC_ARR[1]}
    if [ "$SRC_LOC" = "" ] ; then SRC_LOC=$SRC_HOST; SRC_HOST="" ; fi
    
    IFS=":"; declare -a MY_DST_ARR=($MY_DST)
    DST_HOST=${MY_DST_ARR[0]}
    DST_LOC=${MY_DST_ARR[1]}
    if [ "$DST_LOC" = "" ] ; then DST_LOC=$DST_HOST; DST_HOST="" ; fi

    # Set IFS back to space :) .... otherwise things will start behave odd
    IFS=" "

    debug "Copy:"
    debug " '$SRC_HOST' ::: $SRC_LOC"
    debug " '$DST_HOST' ::: $DST_LOC"

    RET=1

    if [ "$SRC_HOST" != "" ] && [ "$DST_HOST" != "" ]
    then
        echo "Currently tm-vmm does not support copying from one client to another"
    elif [ "$SRC_HOST" != "" ]
    then
        debug copy_from_client $SRC_HOST $SRC_LOC $DST_LOC
        copy_from_client $SRC_HOST $SRC_LOC $DST_LOC
        RET=$?
    elif [ "$DST_HOST" != "" ]
    then
        debug copy_to_client $SRC_LOC $DST_HOST $DST_LOC
        copy_to_client $SRC_LOC $DST_HOST $DST_LOC
        RET=$?
    else
        echo "uh oh"
    fi

    echo "RETURN $RET"

    return $RET
}

unlock_screen()
{
    CLIENT=$1
    RET=1

    case $VM_TYPE in
        "VirtualBox")
         echo "VBOX unlock screen"
         RET=1
         ;;
        "qemu")
         echo "QEMU unlock screen"
         RET=1
         ;;
        
        "Android")
         exec_client_command $CLIENT "input keyevent 82"
         RET=$?
         ;;
        
        *)
         echo "Screenshots not implemented for $1"
         RET=1
         ;;
    esac

    return $RET
}

get_suffix_from_file()
{
    MY_FILE=$1
    debug "get_suffix_from_file() MY_FILE: $MY_FILE"

    MY_FILE_SHORT=$(basename "$MY_FILE")
    debug "get_suffix_from_file() MY_FILE_SHORT: $MY_FILE_SHORT"

    MY_FILE_PREFIX=${MY_FILE_SHORT%.*}
    debug "get_suffix_from_file() MY_FILE_PREFIX: $MY_FILE_PREFIX"

    MY_FILE_SUFFIX=${MY_FILE_SHORT##*.}
    debug "get_suffix_from_file() MY_FILE_SUFFIX: $MY_FILE_SUFFIX"

    echo $MY_FILE_SUFFIX
    
}

android_install_app()
{
    CLIENT=$1
    APP=$2
    MODE=$3

    exec_client_raw_android "$ANDROID_PORT" "$MODE $APP"
}

vbox_install_app()
{
    CLIENT=$1
    APP=$2
    MODE=$3

    APP_SUF=$(get_suffix_from_file "$APP")

    if [ "$MODE" = "uninstall" ]
    then
        exec_client_command_as_root $CLIENT "dpkg --remove $APP"
        RET=$?
        
    else

        case $APP_SUF in
         "deb")
                echo "VBOX is trying to install deb pkg: $APP"
                copy_to_client $APP $CLIENT "/tmp"
                RET=$?
                if [ "$RET" != "0" ]; then
                 echo "Installation failed: copy deb pkg to client failed."
                 return $RET
                fi
                
                exec_client_command_as_root $CLIENT "dpkg --install /tmp/$(basename $APP)"
                RET=$?
                if [ "$RET" != "0" ]; then
                 echo "Installation failed: dpkg --install app failed."
                 return $RET
                fi
                
                exec_client_command_as_root $CLIENT "rm -f /tmp/$(basename $APP)"
                RET=$?

                ;;
         "rpm")
                echo "VBOX is trying to install rpm pkg: $APP"
                copy_to_client $APP $CLIENT "/tmp"
                RET=$?
                if [ "$RET" != "0" ]; then
                 echo "Installation failed: copy rmp pkge to client failed."
                 return $RET
                fi

                exec_client_command_as_root $CLIENT "rpm --install /tmp/$(basename $APP)"
                RET=$?
                if [ "$RET" != "0" ]; then
                 echo "Installation failed: rpm --install app failed."
                 return $RET
                fi
                ;;
         *)
                echo "Don't know how to install $APP_SUF packages"
                RET=1
                ;;
        esac
    fi

    if [ "$RET" = "0" ]
    then
        echo "Installation succeeded!"
    fi

    return $RET
}


get_guest_os_for_client_vbox()
{
    CLIENT="$1"

    GUEST_OS_TMP=$(vboxmanage showvminfo "$CLIENT" | grep "Guest OS:" | awk ' {print $3}')

    echo $GUEST_OS_TMP
    return 0
}

get_guest_os_for_client_android()
{
    GUEST_OS_TMP="Android"

    echo "$GUEST_OS_TMP"
    echo " Version: $($ADB -s emulator-$1 shell getprop ro.build.version.release)"
    # TODO: Some problem going on here - will fix later.
    # echo " Kernel version: $(adb -s emulator-$1 shell cat /proc/version)"
    # echo " Build number: $($ADB -s emulator-$1 shell getprop ro.build.description)"

    return 0
}

get_guest_os_for_client()
{
    CLIENT="$1"

    export GUEST_OS=""

    case $VM_TYPE in
        "VirtualBox")
         GUEST_OS=$(get_guest_os_for_client_vbox "$CLIENT")
         RET=$?
         ;;
        "qemu")
         echo "QEMU get_guest_os_for_client()"
         RET=1
         ;;
        
        "Android")
         GUEST_OS=$(get_guest_os_for_client_android "$ANDROID_PORT")
         RET=$?
         ;;
        
        *)
         echo "get_guest_os_for_client() not implemented for $VM_TYPE"
         RET=1
         ;;
    esac
    
    return $RET
}

vbox_uninstall_app()
{
    CLIENT=$1
    APP=$2
    MODE=$3

    get_guest_os_for_client "$CLIENT"

    case $GUEST_OS in
        "Ubuntu")
         exec_client_command_as_root $CLIENT "dpkg --remove $APP"
         RET=$?
        
         ;;
        "Fedora")
         echo "Fedora uninstall not implemented"
         RET=1
         ;;
        "RedHat")
         echo "RedHat uninstall not implemented"
         RET=1
         ;;
        *)
         echo "Don't know how to uninstall packages on $GUEST_OS"
         RET=1
         ;;
    esac

    return $RET
}

uninstall_app()
{
    CLIENT="$1"
    APP="$2"
    RET=1

    case $VM_TYPE in
        "VirtualBox")
         echo "VBOX uninstall app: $APP"
         vbox_uninstall_app "$CLIENT" "$APP"
         RET=$?
         ;;
        "qemu")
         echo "QEMU uninstall app: $APP"
         RET=1
         ;;
        
        "Android")
         echo "Android uninstall app on $CLIENT $APP"
         android_install_app "$CLIENT" "$APP" "uninstall"
         RET=$?
         ;;
        
        *)
         echo "Screenshots not implemented for $1"
         RET=1
         ;;
    esac
    
    return $RET
}

install_app()
{
    CLIENT="$1"
    APP="$2"
    RET=1

    case $VM_TYPE in
        "VirtualBox")
         echo "VBOX install app: $APP"
         vbox_install_app "$CLIENT" "$APP"
         RET=$?
         ;;
        "qemu")
         echo "QEMU install app: $APP"
         RET=1
         ;;
        
        "Android")
         echo "Android install app on $CLIENT $APP"
         android_install_app "$CLIENT" "$APP" "install"
         RET=$?
         ;;
        
        *)
         echo "Screenshots not implemented for $1"
         RET=1
         ;;
    esac

    return $RET
}

print_client_settings()
{
    CLIENT=$1
    cat $CLI_CONF
}
