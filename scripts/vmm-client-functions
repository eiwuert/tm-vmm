#
#
# Testing Machine
#
# Copyright (C) 2012, 2013 TIS Innovation Park
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or any later version.
#
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Boston,
# MA 02110-1301, USA.
#

declare -a SCRIPTS_TO_EXECUTE
export SCRIPTS_TO_EXECUTE

ANDROID_SPEC_FILE=$(dirname $0)/../share/testingmachine/scripts/vmm-client-android-specific
if [ -f $ANDROID_SPEC_FILE ]
then
    source $ANDROID_SPEC_FILE
else
    echo "Can't find $ANDROID_SPEC_FILE"
    exit 1
fi

QEMU_SPEC_FILE=$(dirname $0)/../share/testingmachine/scripts/vmm-client-qemu-specific
if [ -f $QEMU_SPEC_FILE ]
then
    source $QEMU_SPEC_FILE
else
    echo "Can't find $QEMU_SPEC_FILE"
    exit 1
fi

list_vbox_machines()
{
    debug "Listing vbox machines"
    VB_NAMES=$(vboxmanage list vms | awk 'BEGIN { FS="\""} { printf "%s;", $2}' | sed 's,\",,g' )
    SAVED_IFS=$IFS
    export IFS=";"

    if [ "$VB_NAMES" != "" ]
    then
        for VB_NAME in $VB_NAMES
        do
            if [ "$VB_NAME" != "" ]
            then
		IFS=$SAVED_IFS
		echo " |--$VB_NAME "
		CONF_CLIENT=$(find $ETC_DIRS -name *.conf 2>/dev/null | grep "clients/" | xargs grep -l $VB_NAME)
		if [ "$CONF_CLIENT" != "" ]
		then
                    VB_SHORT_NAME=$(basename $CONF_CLIENT)
                    echo "   |--$VB_SHORT_NAME (client)"
		else
                    echo "   |--no conf file yet"
		fi
            fi
        done
    else
         echo " no virtualbox machines found"
    fi
    IFS=$SAVED_IFS
}


list_machines()
{
    debug "Listing available machines:"
    echo "Available machines:"
    echo " VirtualBox"
    list_vbox_machines
    echo " Android"
    list_android_machines
}

client_names()
{
    for d in $ETC_DIRS
    do
        for i in $(find $d/clients -name "*.conf" 2>/dev/null)
        do
	    CLIENT_NAME=$(basename $i)
	    CLIENT_NAME=${CLIENT_NAME:0:-5}
	    CLIENT_NAMES="$CLIENT_NAMES;$CLIENT_NAME"
	done
    done
    CLIENT_NAMES=$(echo $CLIENT_NAMES | awk '{print substr($1, 2)}')
    echo $CLIENT_NAMES
}


list_clients()
{
    debug_enter "Listing available clients"

    echo "Available clients:"
    for d in $ETC_DIRS
    do
        debug_enter " entering dir $d"
        debug " in dir $d"
        for i in $(find $d/clients -name "*.conf" 2>/dev/null)
        do
         debug_enter " using file $i"
         debug " file: $i"
         TYPE=$(grep VM_TYPE "$i" | sed 's,[ ]*VM_TYPE=,,g' | sed 's,\",,g')
         echo -n " "
         printf "%s " $(basename $i | sed 's,\.conf,,g' )
         printf " [%.12s] ($i)\n" $TYPE
         debug_leave " "
        done
        debug_leave " "
    done

    debug_leave "list_clients"
}


list_running_vbox()
{
    echo "  VirtualBox"
    VB_NAMES=$(vboxmanage list runningvms | awk 'BEGIN { FS="\""} { printf "%s;", $2}' | sed 's,\",,g' )
    SAVED_IFS=$IFS
    export IFS=";"

    if [ "$VB_NAMES" != "" ]
    then
        for VB_NAME in $VB_NAMES
        do
         if [ "$VB_NAME" != "" ]
         then
                IFS=$SAVED_IFS
                CONF_CLIENT=$(find $ETC_DIRS -name *.conf 2>/dev/null | grep "clients/" | xargs grep -l $VB_NAME)
                if [ "$CONF_CLIENT" != "" ]
                then
                    VB_SHORT_NAME=$(basename $CONF_CLIENT | sed 's,\.conf,,g')
                    echo "    |--$VB_SHORT_NAME [$CONF_CLIENT] (machine: $VB_NAME )"
                fi
         fi
        done
    else
        echo "   No virtualbox machines is currently running."
    fi
    IFS=$SAVED_IFS
}


list_running_vbox_machines()
{
    echo "  VirtualBox"
    VB_NAME=$(vboxmanage list runningvms | awk ' { printf "%s", $1}' | sed 's,\",,g')
    if [ "$VB_NAME" != "" ]
    then
        SAVED_IFS=$IFS
            export IFS=";"
        for i in $VB_NAME
        do
            echo "  |--$i  "
            FOUND=0
            for dir in  $(echo $ETC_DIRS | sed 's, ,;,'g)
            do
                if [ -d $dir ]
                then
                    for vb in $(find $dir/clients -name *.conf | xargs grep -l $i )
                    do
                        VB_SHORT_NAME=$(basename $vb)
                        echo "    |--$VB_SHORT_NAME  [$vb] (client)"  
                        FOUND=1
                    done
                fi
            done
            if [ $FOUND -eq 0 ] ; then echo "    * vbox is not in use"; fi
        done
        IFS=$SAVED_IFS
    else
        echo "   no virtualbox machines currently running"
    fi
}


list_running_clients()
{
    echo "Running clients:"
    list_running_vbox
    list_running_android
    list_running_qemu
}

list_running_machines()
{
    echo "Running machines:"
    
    list_running_vbox_machines
    list_running_android_machines
}

start_client()
{
    debug "start_client"

    START_ARGS=$1

    case $VM_TYPE in
        "VirtualBox")

         if [ "$START_ARGS" = "headless" ] ; then
                start_vbox_headless
                RET=$?
         else
                start_vbox
                RET=$?
         fi

         if [ $RET -ne 0 ] ; then
                debug "Failed to start \"$VM_NAME\"."
                echo "Failed to start \"$VM_NAME\"."
                return 1
         fi

         check_vbox_proc
         RET=$?
        
         if [ $RET -ne 0 ] ; then
             OK=0
         else
             OK=1
         fi
         ;;
	
        "Android")
	    
            if [ "$START_ARGS" = "headless" ] ; then
                start_android_headless
                sleep 2
            else
                start_android
                sleep 2
            fi
            ;;
	
        "qemu")
            debug "Starting qemu \"$WANTED_CLIENT\"."
            start_qemu "$WANTED_CLIENT" "&"
	    
            check_qemu_proc $VM_NAME
            RET=$?
            
            if [ $RET -ne 0 ] ; then
		OK=0
            else
		OK=1
            fi
# Shouldn't be removed???
#        OK=$?
         log "$OK" "Start qemu" "$VM_NAME"
         ;;

        *)
         echo "Failed finding vm type for \"$WANTED_CLIENT\"."
         log "1" "Unknown vm type" "$VM_NAME"
         exit
         ;;
    esac
# Shouldn't be removed??? $2 == $VM_TYPE
    # if [ "$2" = "--no-wait" ]
    # then
    #     return 0
    # fi

    wait_until_up
}

start_vbox()
{
    debug "start_vbox"

    if [ $(vboxmanage list vms | grep -c "$VM_NAME" | wc -l) -eq 0 ]
    then
        debug "Could not find vbox image \"$VM_NAME\"."
        return 1
    fi
    ERR_FILE=$TM_TMP_FILE_DIR/$$.vbm-err
    rm -f $ERR_FILE
    VBoxManage startvm "$VM_NAME" 2> $ERR_FILE >/dev/null &
    sleep 3

    ERROR_FOUND=$(grep -e "error" $ERR_FILE | wc -l)
    if [ "$ERROR_FOUND" != "0" ]
    then
        debug "Could not start vbox. Error message:"
        debug "$(cat $ERR_FILE)"
        rm -f $ERR_FILE
        return 1
    fi
    rm -f $ERR_FILE
    maximise_vbox "$VM_NAME"
    return 0
}

start_vbox_headless()
{
    debug "start_vbox_headless.
"
    if [ $(vboxmanage list vms | grep "$VM_NAME" | wc -l) -eq 0 ]
        then
        debug "Could not find vbox image \"$VM_NAME\"."
        return 1
    fi

    debug "start_vbox_headless: vboxheadless -s  \"$VM_NAME\""
    ERR_FILE=.$$.vbm-err
    rm -f $ERR_FILE
    vboxheadless -s  "$VM_NAME"  > $ERR_FILE  2>&1  &

    sleep 5
    ERROR_FOUND=$(grep -i -e "error" $ERR_FILE  | wc -l)
    ALREADY_STARTED=$(grep -i -e "already locked for" $ERR_FILE  | wc -l)

    if [ "$ALREADY_STARTED" == "0" ] && [ "$ERROR_FOUND" != "0" ] 
    then   
	debug "Could not start vbox (headless). Error message:"
	debug "$(cat $ERR_FILE)"
	rm -f $ERR_FILE
	return 1
    fi	

    vboxheadless -s "$VM_NAME" 2> $ERR_FILE >/dev/null &
    rm -f $ERR_FILE

    return 0
}


check_vbox_proc()
{
    RET=$(ps -u `whoami` awww | grep -i virtualbox | grep -c "$VM_NAME" )

    debug "Number of vbox processes: $RET"
    
    return $RET
}

maximise_vbox()
{
    VN_NAME=$1

    debug "Will try to maximise VirtualBox window"
    CTR=0
    WIN_ID=""

    export WMCTRL=$(which wmctrl)

    if [ "$WMCTRL" = "" ]
    then
        echo "Command wmctrl missing on host"
        echo "Cannot maximise the window"
        debug "Command wmctrl missing on host"
        debug "Cannot maximise the window"
        return 1
    fi

    while [ "$WIN_ID" = "" ]
    do
        debug "Waiting for VirtualBox window to appear"
        countdowner 5
        WIN_ID=$($WMCTRL -l | grep VirtualBox | grep -v Manager | grep $VM_NAME | awk ' { print $1}')
        CTR=$(( $CTR + 1))
        debug " current id:$WIN_ID"
        if [ $CTR -gt 10 ]
        then
         debug " We've been waiting long enough"
         RET=1
         break
        fi
    done
    
    if [ "$WIN_ID" != "" ]
    then
        debug "Maximising window: $WIN_ID"
        sleep 2
        $WMCTRL -i -r $WIN_ID -b add,maximized_vert,maximized_horz
        RET=$?
    fi

    return $RET
}

kill_vb_proc()
{
    KILL_ARG=$1

    debug "Kill vb proc \"$VM_NAME\" ($KILL_ARG)"

    sleep 5
    VBID=$(ps auxww | grep -i virtualbox | grep -v grep | grep "$VM_NAME" | awk ' { print $1 }')
    if [ "$VBID" != "" ] ; then
        debug "Still a vbox id to slay.. kill $KILL_ARG $VBID"
        kill $VBID 2>/dev/null
    fi
}

kill_vbox()
{
    kill_vb_proc
    kill_vb_proc "-9"
}

stop_vbox()
{
    debug "stop_vbox: \"$VM_NAME\"."

    is_vbox_up
    # vbox client up, RET = 0; vbox client down, RET = 1
    RET=$?

    if [ $RET = 1 ] ; then
	debug "\"$VM_NAME\" is down."
	echo "\"$VM_NAME\" is down."
        return 0
    else
        debug " Sending acpipowerbutton off to $VM_NAME"
	# Press ACPI powerbutton off
	VBoxManage controlvm "$VM_NAME" acpipowerbutton off 2>/dev/null
        wait_until_down

	is_vbox_up
	# vbox up, RET = 0; vbox down, RET = 1
	RET=$?

	if [ $RET = 1 ] ; then
	    debug "\"$VM_NAME\" is down."
	    echo "\"$VM_NAME\" is down."
	    return 0
	else
            debug "Power on still after pressing ACPI power off."
            debug "Do a \"hard\" poweroff to \"$VM_NAME\" ."
            VBoxManage controlvm "$VM_NAME" poweroff 2>/dev/null
            wait_until_down
	fi
    fi
}


stop_client()
{
    debug "stop_client: $VM_NAME"

    is_client_shell_up
    RET=$?

    if [ "$RET" = "0" ]
    then
        if [ "$VM_SUPERUSER" != "" ] && [ "$SSH_SHUTDOWN_COMMAND" != "" ]
        then
            debug "Super user account available"
            debug " trying to stop via ssh"
            $SSH $SSH_TEST_OPTIONS -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS $SSH_SHUTDOWN_COMMAND 2>/dev/null
            RET=$?
            if [ "$RET" != "0" ]
            then
                debug "Failed stopping client with ssh"
                debug " Command: $SSH $SSH_TEST_OPTIONS -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS $SSH_SHUTDOWN_COMMAND"
            else
		wait_until_down
		return 0
            fi
        else
            debug "Missing credentials to stop via ssh and super user"
        fi
    else
	debug "Host \"$VM_NAME\" ssh seems down."
    fi

    debug "Stop \"$VM_NAME\" using virtual machine ($VM_TYPE)"

    case $VM_TYPE in
        "VirtualBox")
	    stop_vbox
            kill_vbox
            check_vbox_proc

            RET=$?
            log "$RET" "Stop VirtualBox" "$VM_NAME"
            return $RET
            ;;

        "qemu")
            stop_qemu "$VM_NAME"

            check_qemu_proc "$VM_NAME"
            RET=$?
            log "$RET" "Stop qemu" "$VM_NAME"
            return $RET
            ;;

        "Android")
            stop_android
	    kill_android
            check_android_proc
            RET=$?
            log "$RET" "Stop Androd" "$VM_NAME"
            return $RET
            ;;

        *)
            echo "Failed finding vm type for $1"
            exit 123
            ;;
    esac
}

pause_client()
{
    debug "pause_client: $VM_NAME ($VM_TYPE)"

    case $VM_TYPE in
        "VirtualBox")
            VBoxManage controlvm "$VM_NAME" pause
#sleep 10 ; VBoxManage controlvm Ubuntu-12.04 pause ; sleep 600 ; VBoxManage controlvm Ubuntu-12.04 resume ; ssh -p 9022 root@localhost ntpdate-debian         kill_vbox $1
            ;;

        "Android")
            echo "Can't pause Android yet!"
            return 1
            ;;

        "qemu")
            echo "Can't pause qemus yet!"
            return 1
            ;;

        *)
            echo "Failed finding vm type for $1"
            exit 123
            ;;
    esac
}

resume_client()
{
    debug "resume_client: $VM_NAME ( $VM_TYPE )"

    case $VM_TYPE in
        "VirtualBox")
            VBoxManage controlvm "$VM_NAME" resume
            printf "\n\n\t*****RESET TIME LATER!!!!\n\n\n"
#sleep 10 ; VBoxManage controlvm Ubuntu-12.04 pause ; sleep 600 ; VBoxManage controlvm Ubuntu-12.04 resume ; ssh -p 9022 root@localhost ntpdate-debian         kill_vbox $1
            ;;

        "qemu")
            echo "Can't pause qemus yet!"
            return 1
            ;;

        *)
            echo "Failed finding vm type for $1"
            exit 123
            ;;
    esac
}

find_vm_type()
{
    VM_NAME=$1
    
    VBOX_FOUND=$(vboxmanage list vms | awk ' BEGIN { FS="\""} { print $2 } ' | sed 's,\",,g' | grep -w $VM_NAME | wc -l)

    ANDROID_FOUND=$(list_android_machines | grep -w $VM_NAME | wc -l)

    debug "find_vm_type: VBOX_FOUND: $VBOX_FOUND"
    debug "find_vm_type: ANDROID_FOUND: $ANDROID_FOUND"

    if [ $VBOX_FOUND -ne 0 ]
    then
        export VM_TYPE="VirtualBox"
    elif [ $ANDROID_FOUND -ne 0 ]
    then
	export VM_TYPE="Android"
    fi
}


start_helper()
{
    debug "start_helper: $*"

    WANTED_NAME=$1
    VM_TYPE=$2
    CLI_CONF=$3
    START_ARGS=$4

    debug "Reading client conf $CLI_CONF"
    .  $CLI_CONF

    case $VM_TYPE in
	"VirtualBox")
	    debug "Starting vbox $1 ($START_ARGS)"
	    if [ "$START_ARGS" = "headless"  ]
	    then
		start_vbox_headless $VM_NAME
		RET=$?
	    else
		start_vbox $VM_NAME
		RET=$?
	    fi

	    if [ $RET -ne 0 ]
		then
		debug "Failed to start: $VM_NAME"
		echo "Failed to start: $VM_NAME"
		return 1
	    fi
	    
	    check_vbox_proc $VM_NAME
	    RET=$?
	    
	    if [ $RET -ne 0 ]
		then
		OK=0
	    else
		OK=1
	    fi

	    OK=$?
	    log "$OK" "Start VirtualBox" "$VM_NAME"
	    ;;
	"Android")
	    debug "Starting android $1 ($START_ARGS)"
	    if [ "$START_ARGS" = "headless"  ]
	    then
		start_android_headless $VM_NAME
	    else
		start_android $VM_NAME
	    fi

		
	    ;;
	"qemu")
	    debug "Starting qemu $1"
	    start_qemu "$WANTED_NAME" "&"

	    check_qemu_proc $VM_NAME
	    RET=$?
	    
	    if [ $RET -ne 0 ]
		then
		OK=0
	    else
		OK=1
	    fi

	    OK=$?
	    log "$OK" "Start qemu" "$VM_NAME"
	    ;;
	*)
	    echo "Failed finding vm type for $1"
	    log "1" "Unknown vm type" "$VM_NAME"
	    exit
	    ;;
    esac
    


    if [ "$2" = "--no-wait" ]
    then
	return 0
    fi
    
    wait_until_up $VM_NAME


}


start_machine()
{
    CLIENT_FOUND=false
    WANTED_VM=$1

    get_info_for_machine $1

    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    else
	start_helper "$WANTED_VM" $VM_TYPE $CLI_CONF
        export VM_TYPE="Android"
    fi
}

start_client_wait_for_ssh()
{
    auto_debug "Starting client $CLIENT_NAME"
    $VMM_CLIENT --start-client $CLIENT_NAME
    
    auto_debug "Wait for ssh"
    $VMM_CLIENT --wait-for-ssh $CLIENT_NAME 300
    RET=$?

    return $RET
}


is_vbox_up()
{
    CNT=$(vboxmanage list runningvms | awk 'BEGIN { FS="\""} { print $2 } ' | sed 's,\",,g' | grep "^${VM_NAME}$" | wc -l)

    # If the VM is running (>1), return 0
    if [ $CNT -eq 1 ]
    then
        debug "vbox vm \"$VM_NAME\" is running."
        return 0
    fi
    debug "vbox vm \"$VM_NAME\" is not running."
    return 1
}


is_client_up()
{
    case $VM_TYPE in
        "VirtualBox")
            is_vbox_up
            RET=$?
            ;;

        "Android")
            is_android_up
            RET=$?
            ;;

        "qemu")
            is_qemu_up $VM_NAME
            RET=$?
            ;;

        *)
	    debug "Failed to find vm type for \"$VM_NAME\"."
            exit 123
            ;;
    esac
    
    debug "is_client_up: $RET ( 0 up, 1 down )"
    return $RET
}


is_client_shell_up()
{
    case $VM_TYPE in
        "VirtualBox")
            is_client_ssh_up $WANTED_VM
            RET=$?
            ;;

        "Android")
            is_android_up $WANTED_VM
            RET=$?
            ;;

        "qemu")
            is_qemu_up $WANTED_VM
            RET=$?
            ;;

        *)
	    debug "Failed finding vm type for \"$WANTED_VM\"."
            echo "Failed finding vm type for \"$WANTED_VM\"."
            exit 123
            ;;
    esac
}


is_client_ssh_up()
{
    # debug "Check if Client ssh server is up"
    # debug " ssh: $SSH"
    # debug " options: $SSH_TEST_OPTIONS"
    # debug " port: -p $SSH_PORT"
    # debug " user $VM_USER@$VM_IP_ADDRESS"
    # debug " command: exit"
    # $SSH $SSH_TEST_OPTIONS \
    #     -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS exit \
    #      2>/dev/null
    # RET=$?
    # debug " Returning: $RET"
    # return $RET

    # Not working for Fedora (uses another ncat).
    # VAL=$(nc -zv localhost $SSH_PORT 2>&1 | grep succeeded | wc -l)

    # Not working when VirtualBox NAT port forwarding.
    # # $SSH_PORT (sometimes?) starts with a space, hence the trimming.
    # PORT=$(echo $SSH_PORT | tr -d ' ')
    # debug "is_client_ssh_up(): 2>/dev/null >/dev/tcp/localhost/$PORT"
    # 2>/dev/null >/dev/tcp/localhost/$PORT
    # RET=$?

    VAL=$(nc -i 1 localhost $SSH_PORT < /dev/null 2> /dev/null | grep '^SSH' | wc -l)

    if [ $VAL = 1 ]; then
        debug "is_client_ssh_up: 0 ( up => 0; not up => not 0 )"
        return 0
    else
        debug "is_client_ssh_up: 1 ( up => 0; not up => not 0 )"
        return 1
    fi
}

is_client_x11_up()
{
    case $VM_TYPE in
        "VirtualBox")
            debug "Check if Client X11 is up on vbox"
	    # RET seems always to be 1.
            exec_client_command "DISPLAY=:0 xdpyinfo 2>/dev/null >/dev/null 2>/dev/null "
            RET=$?
            ;;
        "qemu")
            echo "Can't check X11 on qemu"
            debug "Can't check X11 on qemu"
            RET=1
            ;;
        "Android")
            echo "Can't check X11 on Android"
            debug "Can't check X11 on Android"
            RET=1
            ;;
        *)
            debug " Unknown vm type"
            echo "Failed finding vm type for $1"
            RET=1
            ;;
    esac

    debug "is_client_x11_up Returning: $RET"
    return $RET
}

is_client_online()
{
    if [ "$VM_TYPE" = "VirtualBox" ]
    then
        echo "Check if Vbox client is online"
        debug " ssh: $SSH"
        debug " options: $SSH_TEST_OPTIONS"
        debug " port: -p $SSH_PORT"
        debug " user $VM_USER@$VM_IP_ADDRESS"
        debug " command: ping -c1 www.google.com"

        $SSH $SSH_TEST_OPTIONS \
            -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS ping -c1 www.google.com \
            > /dev/null

        RET=$?
    fi

    if [ "$VM_TYPE" = "Android" ]
    then

        ANDROID_PORT=$(get_avd_port_for_name "$VM_NAME")
        echo "Check if Android client is online"

        debug " client: $VM_NAME"
        debug " adb: $ADB"
        debug " port: $ANDROID_PORT"
        debug " command: ping -c1 www.google.com"

        $ADB -s emulator-$ANDROID_PORT shell ping -c1 www.google.com > /dev/null

        RET=$?
    fi

    debug " Returning: $RET"
    if [ "$RET" = "0" ]
    then
    ## printf probably a little silly here
        printf " Google can be reached...\n"
    else
        printf " Google can NOT be reached...\n"
    fi

    return $RET
}

# eGov specific, is service actually online, if not abort...
#is_egovonline()
#{
# if ping -c1 account.egov.bz.it > /dev/null
# then echo "eGov online..."
# else
# echo "Abort, server nor reachable"
# fi
#}

wait_for_shell()
{
    EXPECTED_STATE="$1"
    TIMEOUT=$2

    debug "Will wait for (ssh) $1 for $2 seconds"
    
    TIMEDOUT=false
    START_SECS=$(date "+%s")
    # Set to a negative integer value
    DIFF=-12

    while [ "$TIMEDOUT" = "false" ]
    do
        BREAK=false

        debug " Check if client is up: "

        is_client_shell_up
        RET=$?
        if [ "$EXPECTED_STATE" = "up" ]
        then
         if [ "$RET" = "0" ]
         then
                BREAK=true
         elif [ "$RET" != "0" ]
         then
                BREAK=false
         fi
        # elif [ "$EXPECTED_STATE" = "down" ] ? in future ?
        # then
        fi

        debug " Should we break? $BREAK "

        if [ "$BREAK" = "true" ]
        then
         break
        fi

        sleep 10
        CURRENT=$(date "+%s")
        DIFF=$(( $START_SECS + $TIMEOUT - $CURRENT))
        debug " Started: $START_SECS Current: $CURRENT Timeout: $TIMEOUT"
        debug " Diff: $DIFF"

        if [ $DIFF -le 0 ]
        then
         TIMEDOUT=true
        fi
        debug " have we timed out? $TIMEDOUT "
    done
    debug "timeout or state reached ... continuing"
}

wait_until_up()
{
    # Set timeout in case it's not set. Move to defaults?
    if [ "$VM_STARTUP_TIMEOUT" = "" ]
    then
        VM_STARTUP_TIMEOUT="10"
    fi
    wait_for_state up $VM_STARTUP_TIMEOUT
}

wait_until_down()
{
    # Set timeout in case it's not set. Move to defaults?
    if [ "$VM_STOP_TIMEOUT" = "" ]
    then
        VM_STOP_TIMEOUT="20"
    fi
    wait_for_state down $VM_STOP_TIMEOUT
}

wait_for_state()
{
    EXPECTED_STATE="$1"
    TIMEOUT=$2

    debug "Will wait vm \"$VM_NAME\" for \"$1\" for \"$2\" seconds."
    
    TIMEDOUT=false
    START_SECS=$(date "+%s")
    # Set to a negative integer value
    DIFF=-12

    while [ "$TIMEDOUT" = "false" ]
    do
        BREAK=false

        is_client_up
        RET=$?

        # Break waiting when the client is up.
        if [ "$EXPECTED_STATE" = "up" ]
        then
            if [ "$RET" = "0" ]
            then
                BREAK=true
		debug "\"$VCLIENT\" is running."
            else
                BREAK=false
		debug "\"$VCLIENT\" is not running yet."
            fi
        # Break waiting when the client is down.
        elif [ "$EXPECTED_STATE" = "down" ]
        then
            if [ "$RET" = "0" ]
            then
                BREAK=false
		debug "\"$VCLIENT\" is still running."
            else
                BREAK=true
		debug "\"$VCLIENT\" is shut down."
            fi
        fi

        debug " Should we break? $BREAK "

        if [ "$BREAK" = "true" ]
        then
            break
        fi

        sleep 10
        CURRENT=$(date "+%s")
        DIFF=$(( $START_SECS + $TIMEOUT - $CURRENT ))
        debug " Started: $START_SECS Current: $CURRENT Timeout: $TIMEOUT"
        debug " Diff: $DIFF"

        if [ $DIFF -le 0 ]
        then
            TIMEDOUT=true
        fi
        debug "Have we timed out? $TIMEDOUT "
    done
    debug "Timeout or state reached ... continuing"
}

check_client_status()
{
    debug "check_client_status"

    case $VM_TYPE in
        "VirtualBox")
         is_vbox_up
         RET=$?
         ;;

        "Android")
         debug " check status with android"
         check_client_android

         RET=$?

         ;;
        "qemu")
         debug " check status with qemu"
         send_to_qemu "$WANTED_VM" "info status" > /dev/null
         RET=$?

         ;;
        *)
         debug " Unknown vm type"
         echo "Failed finding vm type for $1"
         exit 123
         ;;
    esac

    if [ $RET = 0 ] ; then
	echo "running"
	return $RET
    else
	echo "not running"
	return 1
    fi
}

check_client_ssh()
{
    debug "Check ssh of \"$VM_NAME\"."
    debug "ssh: $SSH option: $SSH_TEST_OPTIONS -p port: $SSH_PORT user: $VM_USER address: $VM_IP_ADDRESS"
    $SSH $SSH_TEST_OPTIONS -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS exit \
        2>/dev/null >/dev/null
    RET=$?
    
    if [ $RET -ne 0 ]
    then
        echo "not available"
        debug " $VM_NAME down or not responding"
    else
        debug " $VM_NAME is ok"
        echo "ok"
    fi

    return $RET
}

print_client()
{
    echo "Configuration file: $CLI_CONF"
    cat $CLI_CONF
}

exec_client_command()
{
    COMMAND="$1"
    # TODO: Currently not in use
    ON_FAIL="$2"

    debug "exec_client_command $1 $2"

    if [ "$VM_TYPE" = "VirtualBox" ]
    then
        debug "$SSH -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS $COMMAND"
        $SSH -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS \
            "$COMMAND"
        RET=$?
    elif [ "$VM_TYPE" = "Android" ]
    then
        exec_client_command_android "$COMMAND"
        RET=$?
    elif [ "$VM_TYPE" = "ssh" ]
    then
        $SSH -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS \
            "$COMMAND"
        RET=$?
    elif [ "$VM_TYPE" = "qemu" ]
    then
        $SSH -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS \
            "$COMMAND"
        RET=$?
    else
        echo "exec_client_command(): support for \"$VM_TYPE\" not implemented yet!"
        RET=1
    fi

    return $RET
}

exec_client_command_as_root()
{
    COMMAND="$1"

    debug "exec_client_command_as_root $1"
    debug "$SSH -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS $COMMAND"
    $SSH -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS \
        "$COMMAND"
    return $?
}


get_ssh_specific_info() 
{
    debug "vm_name: $VM_NAME"
    if [ "$SSH_PORT" = "auto" ] ; then
	SSH_PORT=22
	return 0
    fi

    if [ "$SSH_PORT" = "" ] ; then
        debug "SSH_PORT is not set."
        return 1
    else
	debug "SSH_PORT is set as $SSH_PORT."
	return 0
    fi
}


get_vbox_specific_info()
{
    debug "vm_name: $VM_NAME"
    if [ "$SSH_PORT" = "auto" ] ; then
        SSH_PORT=$(vboxmanage showvminfo "$VM_NAME" 2>/dev/null | grep "NIC" | grep -e Rule -e ssh | grep 22 | grep "host port" | sed 's,[a-zA-Z0-9,: \ =()]*host port[ \t]*=,,g' | cut -d, -f1 )
	return 0
    fi

    if [ "$SSH_PORT" = "" ] ; then
        debug "SSH_PORT is not set."
        return 1
    else
	debug "SSH_PORT is set as $SSH_PORT."
	return 0
    fi

    
#    CLIENT_VBOX_IP


}

get_vm_specific_info()
{
    RET=1
    if [ "$VM_TYPE" = "VirtualBox" ]
    then
        get_vbox_specific_info
        RET=$?
    elif [ "$VM_TYPE" = "Android" ]
    then
        get_android_specific_info
        RET=$?
    elif [ "$VM_TYPE" = "ssh" ]
    then
        get_ssh_specific_info
        RET=$?
    elif [ "$VM_TYPE" = "qemu" ]
    then
        RET=0
    else
        echo "get_vm_specific_info(): support for \"$VM_NAME\" not implemented yet!"
    fi
    return $RET
}

get_info_for_client()
{
    debug "get_info_for_client \"$1\"."
    WANTED_CLIENT=$1
    CLI_CONF=""
    CONF_FOUND=false

    for ETC_DIR in $ETC_DIRS
    do
        CLI_CONF=$(find $ETC_DIR/clients -name "$WANTED_CLIENT.conf" 2>/dev/null)

	if [ "$CLI_CONF" != "" ] ; then
	    CONF_FOUND=true
            . $CLI_CONF
            export VM_NAME=$(grep VM_NAME $CLI_CONF | sed -e 's,VM_NAME=,,g' -e 's,\",,g' )
	    debug "Got client conf info."
	    debug "Sourced conf file: $(cat $CLI_CONF)"

            get_vm_specific_info
            RET=$?
            if [ $RET -ne 0 ] ; then
		debug "Client \"$WANTED_CLIENT\" seems to be down"
		debug "exit tm-vmm."
		if [ $EXIT_ON_CLIENT_INFO_FAILURE = 0 ]; then
		    exit 1
		else
		    return 1
		fi
	    else
		debug "Got vm specific info."
		break
	    fi
        fi
    done

    if [ $CONF_FOUND = true ] ; then
	case $VM_TYPE in
	   VirtualBox)
		check_vbox_vm_existence $VM_NAME
		if [ 0 = $? ] ; then
		    return 0
		else
		    debug "Can't find vbox machine \"$VM_NAME\"."
		    echo "Can't find vbox machine \"$VM_NAME\"."
		    if [ $EXIT_ON_CLIENT_INFO_FAILURE = 0 ]; then
			exit 1
		    else
			return 1
		    fi
		fi
		;;

	    Android)
		check_android_vm_existence $VM_NAME
		if [ 0 = $? ] ; then
		    return 0
		else
		    debug "Can't find android machine \"$VM_NAME\"."
		    echo "Can't find android machine \"$VM_NAME\"."
		    if [ $EXIT_ON_CLIENT_INFO_FAILURE = 0 ]; then
			exit 1
		    else
			return 1
		    fi
		fi
		;;

	    qemu)
		echo "WARNING, ONLY BASIC QEMU IMPL"
		return 0
		;;

	    ssh)
		return 0
		;;

	    # qemu in the future?

	    *)
		debug "Not implemented for this type of vm yet."
		echo "Not implemented for this type of vm yet."
		if [ $EXIT_ON_CLIENT_INFO_FAILURE = 0 ]; then
		    exit 1
		else
		    return 1
		fi
	esac
    else
	debug "Can't find .conf file for \"$WANTED_CLIENT\"."
	echo "Can't not find .conf file for \"$WANTED_CLIENT\"."

	check_vbox_vm_existence $WANTED_CLIENT
	RET_VBOX=$?
	check_android_vm_existence $WANTED_CLIENT
	RET_ANDROID=$?

	if [ $RET_VBOX = 0 ] ; then
	    if [ $RET_ANDROID = 0 ] ; then
	        # No configation found, multiple virtual machines found, exit 1
		talk_to_user Multi
		RET=$?
	    fi
	    # No configuration found, only one vbox vm, continue or exit 0
	    talk_to_user VirtualBox
	    RET=$?

	elif [ $RET_ANDROID = 0 ] ; then
	    # No configuration found, only one android vm, continue or exit 0
	    talk_to_user Android
	    RET=$?
	else
	    debug "Can't find any info for \"$WANTED_CLIENT\"."
	    echo "Can't find any info for \"$WANTED_CLIENT\"."
	    RET=1
	fi

	if [ $RET != 0 ] ; then
	    if [ $EXIT_ON_CLIENT_INFO_FAILURE = 0 ]; then
		exit $RET
	    else
		return 1
	    fi
	fi

	return $RET
    fi
}

talk_to_user()
{
    VM_TYPE=$1
    ANSWER=""
    RET=1

    if [ $VM_TYPE = Multi ] ; then
	echo "There are more than one virtual machine named \"$WANTED_CLIENT\"."
	echo "You have to manually create a configuration file."
	RET=2
    else
	echo "There is a $VM_TYPE machine named \"$WANTED_CLIENT\" that does not have a .conf file yet."
	echo -n "To create a configuration file enter \"y\" and press Enter; to quit tm-vmm enter\"n\" and press Enter: "
    fi

    read ANSWER

    while [ $ANSWER != y ] && [ $ANSWER != n ]
    do
	echo "Invalid input. Try again."
	read ANSWER
    done

    if [ $ANSWER = y ] ; then
	case $VM_TYPE in
	    VirtualBox)
		create_vbox_client_conf $WANTED_CLIENT

		CLI_CONF="$CONF_NAME"
		. $CLI_CONF
		;;

	    Android)
		create_android_client_conf $WANTED_CLIENT

		CLI_CONF="$CONF_NAME"
		. $CLI_CONF
		;;

	    qemu)
		echo "not implemented yet"
		;;
	esac
	RET=0
    fi

    return $RET
}

check_vbox_vm_existence()
{
    WANTED_VM=$1
    debug "check_vbox_vm_existence: \"$WANTED_VM\""
    CNT=0

    CNT=$(vboxmanage list vms | grep \"$WANTED_VM\" | wc -l)

    debug "Found $CNT vbox machine named \"$WANTED_VM\"."
    if [ $CNT = 1 ] ; then
	return 0
    else
	return 1
    fi
}


vnc_snapshot()
{
    rm -f tmp.jpg
    vncsnapshot :5 tmp.jpg
}

vbox_snapshot()
{
    VBoxManage controlvm "$VM_NAME" screenshotpng "$1"
}

android_snapshot()
{
    # COmmand line fron http://blog.shvetsov.com/2013/02/grab-android-screenshot-to-computer-via.html
    if [ "$ANDROID_SYS" != "physical" ]
    then
        $ADB -s emulator-$ANDROID_PORT shell screencap -p | perl -pe 's/\x0D\x0A/\x0A/g' > "$1"
    else
        $ADB -s $VM_NAME shell screencap -p | perl -pe 's/\x0D\x0A/\x0A/g' > "$1"
    fi
}

rename_screenshot_name()
{
    export IMG=$1
    LAST_PIC=$(ls -1t Screenshot-$1-*.jpg | head -1)

    LAST_NR=$(echo $LAST_PIC | sed -e "s,Screenshot-$IMG\-,,g" -e "s,.jpg,,g")

    NEXT_NR=$(( $LAST_NR + 1 ))
    NEXT_NR_STR=$(printf "%.3d" $NEXT_NR)

    NEXT_IMG=Screenshot-$1-$NEXT_NR_STR.jpg

    mv tmp.jpg $NEXT_IMG
}

client_screenshot()
{
    IMG_NAME=$1
    debug "client_screenshot $VM_NAME"
    if [ "$IMG_NAME" = "" ] ; then
	# Use default path, default name
	if [ ! -d $TM_IMAGE_DIR ] ; then
	    mkdir -p $TM_IMAGE_DIR ; fi
	PIC_NAME=$TM_IMAGE_DIR/image-$VM_NAME-`date +%s`.png
    else
	if [ -d "$IMG_NAME" ] ; then
	# Use $IMG_NAME path, default name
	    PIC_NAME="$IMG_NAME"/image-$VM_NAME-`date +%s`.png
	else
	    if [ "$(dirname "$IMG_NAME")" = "." ] ; then
	# Use current path, name as $IMG_NAME
		PIC_NAME=./"$IMG_NAME"
	    elif [ -d $(dirname "$IMG_NAME") ] ; then
	# Use absolute path, name as $IMG_NAME
		PIC_NAME="$IMG_NAME"
	    else
		debug "Can't identify user input: $IMG_NAME."
		echo "Can't identify user input: $IMG_NAME."
		return 1
	    fi
	fi
    fi

    case $VM_TYPE in
        "VirtualBox")
            vbox_snapshot "$PIC_NAME"
            ;;
        "qemu")
            vnc_snapshot > /dev/null 2> /dev/null
            ;;
        
        "Android")
            android_snapshot "$PIC_NAME"
         # > /dev/null 2> /dev/null
            ;;
        
        *)
            echo "Screenshots not implemented for $1"
            ;;
    esac

    # if [ -f tmp.jpg ]
    # then
    #     rename_screenshot_name $1
    #     echo "Stored: \"$NEXT_IMG\""
    # else
    #     echo "Uh oh"
    # fi
}

auto_debug()
{
    debug "[$VMM_AUTO_NAME] $*"
}

exec_user_scripts()
{
    TMP=0
    export script=bogus
    while [ "$script" != "" ]
    do
        
        LINE=${SCRIPTS_TO_EXECUTE[$TMP]}
        if [ "$LINE" = "" ] ; then break ; fi
        auto_debug "Executing user supplied script: $script"
        
        TYPE=${LINE:0:9}
        script=${LINE:9}
        
        if [ "$TYPE" = "rem-user:" ]
        then
         echo ${VMM_CLIENT} --client-exec ${CLIENT_NAME} "\"${script}\"" | bash
        elif [ "$TYPE" = "rem-root:" ]
        then
         echo ${VMM_CLIENT} --client-exec-as-root ${CLIENT_NAME} "\"${script}\"" | bash
        else
         ${script}
        fi
        
        RET=$?
        auto_debug "User supplied script ($script)returned: $RET"
        
        if [ $RET -ne 0 ]
        then
         return $RET
        fi
        
        TMP=$(( $TMP + 1 ))
    done

    return 0
}

open_shell()
{
    case $VM_TYPE in
        "VirtualBox")
	    open_ssh 
         ;;
    
        "Android")
	    get_android_specific_info $WANTED_VM
            AP=$(get_avd_port_for_name $WANTED_VM)
	    if [ "$ANDROID_SYS" != "physical" ] ;
	    then
		ANDROID_DEV=emulator-$AP
	    else
		ANDROID_DEV=$WANTED_VM
	    fi

	    $ADB -s $ANDROID_DEV shell
         ;;

        *)
         echo "open_shell does not support $VM_TYPE yet"
         return 1
         ;;
    esac

    return 0
}

open_ssh()
{
    $SSH $SSH_TEST_OPTIONS \
        -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS
        
    return $?
}

import_appliance()
{
    OVA_FILE="$1"
    if [ ! -f "$OVA_FILE" ]
    then
        echo "Can't find the ova file $OVA_FILE"
        return 1
    fi

    VBoxManage import "$OVA_FILE"
}

copy_from_client()
{
    MY_SRC_HOST="$1"
    MY_SRC_LOC="${2// /\ }"
    MY_DST_LOC="$3"

    debug "copy_from_client ($VM_TYPE): $MY_SRC_HOST $MY_SRC_LOC $MY_DST_LOC"

    
    case $VM_TYPE in
        "VirtualBox")
            $SCP -r -P $SSH_PORT $VM_USER@$VM_IP_ADDRESS:"$MY_SRC_LOC" "$MY_DST_LOC"
            ;;
	
        "Android")
            $ADB -s emulator-$ANDROID_PORT pull "$MY_SRC_LOC" "$MY_DST_LOC"
            ;;
        *)
            echo "copy not supported"
            return 1
            ;;
    esac

    return 0
}

copy_to_client()
{
    MY_SRC_LOC="$1"
    MY_DST_HOST="$2"
    MY_DST_LOC="${3// /\ }"

    debug "copy_to_client ($VM_TYPE): $MY_SRC_LOC $MY_DST_HOST $MY_DST_LOC"
    case $VM_TYPE in
        "VirtualBox")
            $SCP -r -P $SSH_PORT "$MY_SRC_LOC" $VM_USER@$VM_IP_ADDRESS:"$MY_DST_LOC"
            ;;
	
        "Android")
            $ADB -s emulator-$ANDROID_PORT push "$MY_SRC_LOC" "$MY_DST_LOC"
            ;;
        *)
            echo "copy not supported"
            return 1
            ;;

    esac
    
    return 0
}

client_copy_file()
{
    MY_SRC="$1"
    MY_DST="$2"
    debug "client_copy_file '$MY_SRC' '$MY_DST'"

    IFS=":"; declare -a MY_SRC_ARR=($MY_SRC)
    SRC_HOST=${MY_SRC_ARR[0]}
    SRC_LOC=${MY_SRC_ARR[1]}
    if [ "$SRC_LOC" = "" ] ; then SRC_LOC=$SRC_HOST; SRC_HOST="" ; fi
    
    IFS=":"; declare -a MY_DST_ARR=($MY_DST)
    DST_HOST=${MY_DST_ARR[0]}
    DST_LOC=${MY_DST_ARR[1]}
    if [ "$DST_LOC" = "" ] ; then DST_LOC=$DST_HOST; DST_HOST="" ; fi

    # Set IFS back to space :) .... otherwise things will start behave odd
    IFS=" "

    debug "Copy:"
    debug " '$SRC_HOST' ::: $SRC_LOC"
    debug " '$DST_HOST' ::: $DST_LOC"

    RET=1

    if [ "$SRC_HOST" != "" ] && [ "$DST_HOST" != "" ]
    then
        echo "Currently tm-vmm does not support copying from one client to another"
    elif [ "$SRC_HOST" != "" ]
    then
	get_info_for_client "$SRC_HOST"
        copy_from_client "$SRC_HOST" "$SRC_LOC" "$DST_LOC"
        RET=$?
    elif [ "$DST_HOST" != "" ]
    then
	get_info_for_client "$DST_HOST"
        copy_to_client "$SRC_LOC" "$MY_DST_HOST" "$DST_LOC"
        RET=$?
    else
        echo "Missing SRC or DST host"
	RET=1
    fi

    return $RET
}

unlock_screen()
{
    CLIENT=$1
    RET=1

    case $VM_TYPE in
        "VirtualBox")
         echo "VBOX unlock screen"
         RET=1
         ;;
        "qemu")
         echo "QEMU unlock screen"
         RET=1
         ;;
        
        "Android")
         exec_client_command "input keyevent 82"
         RET=$?
         ;;
        
        *)
         echo "Screenshots not implemented for $1"
         RET=1
         ;;
    esac

    return $RET
}

get_suffix_from_file()
{
    MY_FILE=$1
    debug "get_suffix_from_file() MY_FILE: $MY_FILE"

    MY_FILE_SHORT=$(basename "$MY_FILE")
    debug "get_suffix_from_file() MY_FILE_SHORT: $MY_FILE_SHORT"

    MY_FILE_PREFIX=${MY_FILE_SHORT%.*}
    debug "get_suffix_from_file() MY_FILE_PREFIX: $MY_FILE_PREFIX"

    MY_FILE_SUFFIX=${MY_FILE_SHORT##*.}
    debug "get_suffix_from_file() MY_FILE_SUFFIX: $MY_FILE_SUFFIX"

    echo $MY_FILE_SUFFIX
    
}

vbox_install_app()
{
    APP=$1
    # Not in use.
    MODE=$2

    APP_SUF=$(get_suffix_from_file "$APP")
    # Not in use.
    if [ "$MODE" = "uninstall" ]
    then
        exec_client_command_as_root "dpkg --remove $APP"
        RET=$?
        
    else

        case $APP_SUF in
         "deb")
                echo "VBOX is trying to install deb pkg: $APP"
                copy_to_client $APP "$VM_NAME" "/tmp"
                RET=$?
                if [ "$RET" != "0" ]; then
                 echo "Installation failed: copy deb pkg to client failed."
                 return $RET
                fi
                
                exec_client_command_as_root "dpkg --install /tmp/$(basename $APP)"
                RET=$?
                if [ "$RET" != "0" ]; then
                 echo "Installation failed: dpkg --install app failed."
                 return $RET
                fi
                
                exec_client_command_as_root "rm -f /tmp/$(basename $APP)"
                RET=$?

                ;;
         "rpm")
                echo "VBOX is trying to install rpm pkg: $APP"
                copy_to_client $APP "$VM_NAME" "/tmp"
                RET=$?
                if [ "$RET" != "0" ]; then
                 echo "Installation failed: copy rmp pkge to client failed."
                 return $RET
                fi

                exec_client_command_as_root "rpm --install /tmp/$(basename $APP)"
                RET=$?
                if [ "$RET" != "0" ]; then
                 echo "Installation failed: rpm --install app failed."
                 return $RET
                fi
                ;;
         *)
                echo "Don't know how to install $APP_SUF packages"
                RET=1
                ;;
        esac
    fi

    if [ "$RET" = "0" ]
    then
        echo "Installation succeeded!"
    fi

    return $RET
}

get_guest_os_for_client_vbox()
{
    GUEST_OS_TMP=$(vboxmanage showvminfo "$VM_NAME" | grep "Guest OS:" | awk ' {print $3}')

    echo $GUEST_OS_TMP
    return 0
}

get_guest_os_for_client()
{
    debug "get_guest_os_for_client: $VM_NAME"

    export GUEST_OS=""

    case $VM_TYPE in
        "VirtualBox")
            GUEST_OS=$(get_guest_os_for_client_vbox)
            RET=$?
            ;;
        "qemu")
            echo "QEMU get_guest_os_for_client()"
            RET=1
            ;;
        
        "Android")
            GUEST_OS=$(get_guest_os_for_client_android)
            RET=$?
            ;;
        
        *)
            echo "get_guest_os_for_client() not implemented for $VM_TYPE"
            RET=1
            ;;
    esac
    
    return $RET
}

vbox_uninstall_app()
{
    APP=$1
    MODE=$2

    get_guest_os_for_client

    case $GUEST_OS in
        "Ubuntu")
         exec_client_command_as_root "dpkg --remove $APP"
         RET=$?
        
         ;;
        "Fedora")
         echo "Fedora uninstall not implemented"
         RET=1
         ;;
        "RedHat")
         echo "RedHat uninstall not implemented"
         RET=1
         ;;
        *)
         echo "Don't know how to uninstall packages on $GUEST_OS"
         RET=1
         ;;
    esac

    return $RET
}

uninstall_app()
{
    APP="$1"
    RET=1

    case $VM_TYPE in
        "VirtualBox")
         echo "VBOX uninstall app: $APP"
         vbox_uninstall_app "$APP"
         RET=$?
         ;;
        "qemu")
         echo "QEMU uninstall app: $APP"
         RET=1
         ;;
        
        "Android")
         echo "Android uninstall app: $APP"
         android_install_app "$APP" "uninstall"
         RET=$?
         ;;
        
        *)
         echo "Screenshots not implemented for $VCLIENT"
         RET=1
         ;;
    esac
    
    return $RET
}

install_app()
{
    APP="$1"
    RET=1

    case $VM_TYPE in
        "VirtualBox")
         echo "VBOX install app: $APP"
         vbox_install_app "$APP"
         RET=$?
         ;;
        "qemu")
         echo "QEMU install app: $APP"
         RET=1
         ;;
        
        "Android")
         echo "Android install app: $APP"
         android_install_app "$APP" "install"
         RET=$?
         ;;
        
        *)
         echo "Screenshots not implemented for $VCLIENT"
         RET=1
         ;;
    esac

    return $RET
}

print_client_settings()
{
    cat $CLI_CONF
}

exec_clients_or_exec_all_clients()
{
    SCRIPT_FILE=$1
    CLIENT_NAMES=$2

    if [ "$CLIENT_NAMES" = "" ]; then
	CLIENT_NAMES=$(client_names)
    fi

    SAVED_IFS=$IFS
    export IFS=";"

    for CLIENT_NAME in $CLIENT_NAMES
    do
	CLIENT_UP=1
	CLIENT_SSH_UP=1
	EXIT_ON_CLIENT_INFO_FAILURE=1
	IFS=$SAVED_IFS
	get_info_for_client "$CLIENT_NAME"
	RET=$?
	debug "Got client info for running script? RET: $RET"
	IFS=";"
	if [ $RET = 0 ]; then
	    debug "start_client $VM_NAME for running the script $SCRIPT_FILE."
	    start_client
	    CLIENT_STARTED=$?
	    COUNTER=0
	    while [ $COUNTER -lt 60 ]; do
		is_client_up
		if [ $? = 0 ]; then
		    CLIENT_UP=0
		    break
		else
		    let COUNTER=COUNTER+1
		    sleep 5
		fi
	    done

	    if [ "$CLIENT_UP" = "0" ] && [ "$VM_TYPE" = "VirtualBox" ]
	    then
		COUNTER=0
		while [ $COUNTER -lt 60 ]; do
		    is_client_ssh_up
		    if [ $? = 0 ]; then
			CLIENT_SSH_UP=0
			break
		    else
			let COUNTER=COUNTER+1
			sleep 5
		    fi
		done
	    fi
            
            if [ "$CLIENT_UP" = 0 ] && [ "$VM_TYPE" = "Android" ]
            then
                ANDROID_DEVICE="emulator-$ANDROID_PORT"
            fi

	    debug "is_client_up: $?" # is_client_up?
	    exec_client
	    stop_client

	    COUNTER=0
	    while [ $COUNTER -lt 60 ]; do
		is_client_up
		if [ $? != 0 ]; then
		    break
		else
		    let COUNTER=COUNTER+1
		    sleep 5
		fi
	    done
	else
	    debug "Continue next client for script..."
	    echo "Continue next client for script..."
	fi
    done

    IFS=$SAVED_IFS
}

exec_client()
{
    CLIENT_NAME=$VM_NAME CLIENT_TYPE=$VM_TYPE CLIENT_STARTED=$CLIENT_STARTED CLIENT_UP=$CLIENT_UP CLIENT_SSH_UP=$CLIENT_SSH_UP ANDROID_DEVICE=$ANDROID_DEVICE bash $SCRIPT_FILE
}
