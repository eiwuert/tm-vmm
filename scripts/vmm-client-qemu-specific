start_qemu()
{
    VM_NAME="$1"

    set_qemu_program $QEMU_CPU

    debug "Starting qemu $1"
    debug " $VM_START_ARGS"
    MONITOR_ARGS="-monitor unix:/tmp/qemu-$VM_NAME.sock,server,nowait "
    REDIR_ARGS="-redir tcp:$SSH_PORT::22 "
    EXTRA_ARGS="-no-reboot -nographic -display none "
    
    START_VM="$QEMU_BINARY -M versatilepb -m 256"
    START_VM="$START_VM -kernel $QEMU_KERNEL -hda $QEMU_HDA"
    START_VM="$START_VM -append \"root=/dev/sda1\" "
    START_VM="$START_VM -initrd $QEMU_INITRD"
    START_VM="$START_VM $MONITOR_ARGS $REDIR_ARGS $EXTRA_ARGS"

    if [ ! -f $QEMU_KERNEL ] || [ ! -f $QEMU_INITRD ] || [ ! -f $QEMU_HDA ]
        then
        debug "Can't find either of:"
        debug " kernel: $QEMU_KERNEL"
        debug " initrd: $QEMU_INITRD"
        debug " hda: $QEMU_HDA"
        return 1
    fi

    if [ "$VNC_PORT" != "" ]
    then
        START_VM="$START_VM -vnc :$VNC_PORT"
    fi
    debug " $START_VM"        
    echo "$START_VM" | bash &
   exit
   
    return 0
# /dev/null
}

set_qemu_program()
{
    WANTED_CPU=$1
    export QEMU_BINARY
    case $WANTED_CPU in
        "arm")
         QEMU_BINARY=qemu-system-arm
         ;;
        "armel")
         QEMU_BINARY=qemu-system-arm
         ;;
        *)
         echo "Unsupported cpu $WANTED_CPU"
         ;;
    esac
}

check_qemu_proc()
{
    PROC_EXPR=$1

    RET=$(ps auxww | grep qemu | grep -c $PROC_EXPR )

    debug "Number of qemu processes: $RET"
    
    return $RET
}

stop_qemu()
{
    VB_NAME=$1
    debug "Stopping qemu $VM_NAME"

    if [ "$VB_NAME" != "" ]
    then

	check_qemu_proc $VB_NAME
	RET=$?
	
	if [ $RET -eq 0 ];
	then
	    return
	fi

        debug "Send to QEMU $VB_NAME: ctrl-alt-delete"
        send_to_qemu $VB_NAME "sendkey ctrl-alt-delete"
        wait_for_state down 20 $VB_NAME

        is_qemu_up $VB_NAME
        RET=$?
        if [ "$RET" != "0" ]
        then
         debug " client is up, returning"
         return
        fi
	check_qemu_proc $VB_NAME
	if [ $? -eq 0 ];
	then
	    return
	fi

        debug "Send to QEMU $VB_NAME: system_powerdown"
        send_to_qemu $VB_NAME "system_powerdown"
        wait_for_state down 20 $VB_NAME

        is_qemu_up $VB_NAME
        RET=$?
        if [ "$RET" != "0" ]
        then
         debug " client is up, returning"
         return
        fi
	check_qemu_proc $VB_NAME
	if [ $? -eq 0 ];
	then
	    return
	fi

        debug "Send to QEMU $VB_NAME: quit"
        send_to_qemu $VB_NAME "quit"
        wait_for_state down 20 $VB_NAME

        break
    fi
}

is_qemu_up()
{
    export WANTED_VM=$1

    CNT=$(send_to_qemu $WANTED_VM "info status" | grep "VM status: running" | wc -l)

    debug " is_qemu_up: $CNT"

    # If the VM is running (>1), return 0
    if [ $CNT -ne 0 ]
    then
        debug "qemu vm \"$WANTED_VM\" is running."
        return 0
    fi

    debug "qemu vm \"$WANTED_VM\" is NOT running."
    return 1
}

send_to_qemu()
{
    WANTED_VM=$1
    MSG=$2

#    echo "MSG: $MSG"
    SOCKET=/tmp/qemu-${WANTED_VM}.sock

    echo "$MSG" | socat - unix-connect:${SOCKET} 2>/dev/null | \
        grep -v "(qemu)" | grep -v "QEMU [0-9\. ]*monitor"
}

android-specific()
{
    echo "Listing running qemu devices not possible at the moment"
}


list_running_qemu() 
{
    echo "  Qemu"
    for token in $(ps x -U autobuilder -u autobuilder  | grep qemu | grep -v grep | grep sock | sed 's, ,\n,g' | grep sock ) 
    do
	token=${token#unix:/tmp/qemu-}
	QEMU_NAME=${token%%.sock,server,nowait}
	IFS=" "
	echo "   |--$QEMU_NAME"  

	SUB_CLIENTS=$(find $ETC_DIRS -name "*.conf" 2>/dev/null | grep "clients/" | xargs grep -l $QEMU_NAME)

#	echo "SUB_CLIENTS: $SUB_CLIENTS"
	if [ "$SUB_CLIENTS" != "" ]
	then
	    for qe in $SUB_CLIENTS
	    do
#		echo " ---- $AD_NAME"
		QE_SHORT_NAME=$(basename $qe)
		echo "     |--$QE_SHORT_NAME  (client)"  
		FOUND=true
	    done
#	    if [ "$FOUND" = "false" ]
#	    then
#		echo "      not in use"
#	    fi
	else
	    echo "     |--$QEMU_NAME  (no clients using it)"  
	fi
	

    done
}
